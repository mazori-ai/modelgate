package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"modelgate/internal/audit"
	"modelgate/internal/domain"
	"modelgate/internal/graphql/generated"
	"modelgate/internal/graphql/model"
	"modelgate/internal/mcp"
	"modelgate/internal/provider"
	"strings"
	"time"

	"github.com/google/uuid"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// Get tenant from context (single-tenant mode uses "default")
	// Validate user credentials from database
	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	user, err := r.PGStore.ValidateUserPassword(ctx, input.Email, input.Password)
	if err != nil || user == nil {
		return nil, errors.New("invalid credentials")
	}

	// Create session
	session, token, err := r.PGStore.CreateSession(ctx, user.ID, 24*time.Hour)
	if err != nil {
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:        user.ID,
			Email:     user.Email,
			Name:      user.Name,
			Role:      user.Role,
			Status:    "active",
			CreatedAt: session.CreatedAt,
		},
		ExpiresAt: session.ExpiresAt,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	return true, nil
}

// CreateRegistrationRequest is the resolver for the createRegistrationRequest field.
// Not supported in single-tenant open source edition
func (r *mutationResolver) CreateRegistrationRequest(ctx context.Context, input model.CreateRegistrationRequestInput) (*model.RegistrationRequest, error) {
	return nil, errors.New("registration requests not supported in single-tenant mode")
}

// Placeholder to maintain code structure - original returned:
//
//	&model.RegistrationRequest{
//	    ID:                req.ID,
//	    OrganizationName:  req.OrganizationName,
//	    OrganizationEmail: req.OrganizationEmail,
//	    AdminName:         req.AdminName,
//	    AdminEmail:        req.AdminEmail,
//
// CreateTenant is the resolver for the createTenant field.
// Not supported in single-tenant open source edition
func (r *mutationResolver) CreateTenant(ctx context.Context, input model.CreateTenantInput) (*model.Tenant, error) {
	return nil, errors.New("multi-tenancy not supported in single-tenant mode")
}

// UpdateTenant is the resolver for the updateTenant field.
// Not supported in single-tenant open source edition
func (r *mutationResolver) UpdateTenant(ctx context.Context, id string, input model.UpdateTenantInput) (*model.Tenant, error) {
	return nil, errors.New("multi-tenancy not supported in single-tenant mode")
}

// DeleteTenant is the resolver for the deleteTenant field.
// Not supported in single-tenant open source edition
func (r *mutationResolver) DeleteTenant(ctx context.Context, id string) (bool, error) {
	return false, errors.New("multi-tenancy not supported in single-tenant mode")
}

// ApproveRegistration is the resolver for the approveRegistration field.
// Not supported in single-tenant open source edition
func (r *mutationResolver) ApproveRegistration(ctx context.Context, input model.ApproveRegistrationInput) (*model.Tenant, error) {
	return nil, errors.New("registration not supported in single-tenant mode")
}

// RejectRegistration is the resolver for the rejectRegistration field.
// Not supported in single-tenant open source edition
func (r *mutationResolver) RejectRegistration(ctx context.Context, input model.RejectRegistrationInput) (bool, error) {
	return false, errors.New("registration not supported in single-tenant mode")
}

// UpdateProvider is the resolver for the updateProvider field.
func (r *mutationResolver) UpdateProvider(ctx context.Context, input model.UpdateProviderInput) (*model.ProviderConfig, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	// Get tenant to check plan limits for connection settings validation
	tenant, err := r.PGStore.GetTenantBySlug(ctx, tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant: %w", err)
	}
	planLimits := tenant.GetEffectivePlanLimits()

	// Build the provider config
	// Convert provider to lowercase to match domain constants
	config := &domain.ProviderConfig{
		Provider:           domain.Provider(strings.ToLower(string(input.Provider))),
		Enabled:            input.Enabled,
		ConnectionSettings: domain.DefaultConnectionSettings(),
	}

	// Get existing config to preserve existing API key if not updating
	existing, err := r.PGStore.GetProviderConfig(ctx, config.Provider)
	if err == nil && existing != nil {
		// Preserve existing values that weren't provided
		if input.APIKey == nil || *input.APIKey == "" {
			config.APIKey = existing.APIKey
		}
		if input.AccessKeyID == nil || *input.AccessKeyID == "" {
			config.AccessKeyID = existing.AccessKeyID
		}
		if input.SecretAccessKey == nil || *input.SecretAccessKey == "" {
			config.SecretAccessKey = existing.SecretAccessKey
		}
		config.BaseURL = existing.BaseURL
		config.Region = existing.Region
		config.RegionPrefix = existing.RegionPrefix
		config.ResourceName = existing.ResourceName
		config.APIVersion = existing.APIVersion
		config.ConnectionSettings = existing.ConnectionSettings
	}

	// Update with new values
	if input.APIKey != nil && *input.APIKey != "" {
		config.APIKey = *input.APIKey
	}
	if input.AccessKeyID != nil && *input.AccessKeyID != "" {
		config.AccessKeyID = *input.AccessKeyID
	}
	if input.SecretAccessKey != nil && *input.SecretAccessKey != "" {
		config.SecretAccessKey = *input.SecretAccessKey
	}
	if input.BaseURL != nil {
		config.BaseURL = *input.BaseURL
	}
	if input.Region != nil {
		config.Region = *input.Region
	}
	if input.ResourceName != nil {
		config.ResourceName = *input.ResourceName
	}
	if input.APIVersion != nil {
		config.APIVersion = *input.APIVersion
	}
	if input.RegionPrefix != nil {
		config.RegionPrefix = *input.RegionPrefix
	}
	if input.ModelsURL != nil {
		config.ModelsURL = *input.ModelsURL
	}

	// Handle connection settings with validation
	if input.ConnectionSettings != nil {
		newConnSettings := convertInputToDomainConnectionSettings(input.ConnectionSettings)

		// Validate against plan limits
		if newConnSettings.MaxConnections > planLimits.MaxConnectionsPerProvider {
			return nil, fmt.Errorf("max_connections (%d) exceeds plan limit (%d). Upgrade your plan to increase.",
				newConnSettings.MaxConnections, planLimits.MaxConnectionsPerProvider)
		}
		if newConnSettings.MaxIdleConnections > planLimits.MaxIdleConnections {
			return nil, fmt.Errorf("max_idle_connections (%d) exceeds plan limit (%d)",
				newConnSettings.MaxIdleConnections, planLimits.MaxIdleConnections)
		}
		if newConnSettings.MaxIdleConnections > newConnSettings.MaxConnections {
			return nil, fmt.Errorf("idle connections (%d) cannot exceed max connections (%d)",
				newConnSettings.MaxIdleConnections, newConnSettings.MaxConnections)
		}

		config.ConnectionSettings = newConnSettings
	}

	// Save to database
	if err := r.PGStore.SaveProviderConfig(ctx, config); err != nil {
		return nil, fmt.Errorf("failed to save provider config: %w", err)
	}

	// Invalidate cached provider clients for this tenant since config changed
	if r.Gateway != nil {
		r.Gateway.InvalidateTenantProviderClients(tenantSlug)
	}

	// If provider is being disabled, delete all models for that provider
	if !input.Enabled {
		if err := r.PGStore.DeleteProviderModels(ctx, string(config.Provider)); err != nil {
			// Log error but don't fail the operation
			fmt.Printf("Warning: failed to delete models for disabled provider %s: %v\n", config.Provider, err)
		}
	}

	// Return the updated config
	hasAPIKey := config.APIKey != ""
	hasAccessKeys := config.AccessKeyID != "" && config.SecretAccessKey != ""

	var streamingMode *string
	if input.Provider == model.ProviderBedrock {
		if hasAccessKeys {
			mode := "true_streaming"
			streamingMode = &mode
		} else if hasAPIKey {
			mode := "simulated_streaming"
			streamingMode = &mode
		}
	}

	return &model.ProviderConfig{
		Provider:           input.Provider,
		Enabled:            input.Enabled,
		HasAPIKey:          hasAPIKey,
		HasAccessKeys:      hasAccessKeys,
		StreamingMode:      streamingMode,
		BaseURL:            input.BaseURL,
		Region:             input.Region,
		ResourceName:       input.ResourceName,
		APIVersion:         input.APIVersion,
		RegionPrefix:       input.RegionPrefix,
		ModelsURL:          input.ModelsURL,
		ConnectionSettings: convertDomainConnectionSettingsToModel(config.ConnectionSettings),
		PlanCeiling:        getPlanCeiling(tenant.Tier),
	}, nil
}

// AddProviderAPIKey is the resolver for the addProviderAPIKey field.
func (r *mutationResolver) AddProviderAPIKey(ctx context.Context, input model.AddProviderAPIKeyInput) (*model.ProviderAPIKey, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	// Get KeySelector
	keySelector := r.Gateway.GetKeySelector()
	if keySelector == nil {
		return nil, errors.New("key selector not available")
	}

	ks, ok := keySelector.(*provider.KeySelector)
	if !ok {
		return nil, errors.New("invalid key selector type")
	}

	// Convert provider enum to domain type
	providerDomain := domain.Provider(strings.ToLower(string(input.Provider)))

	// Extract optional fields
	name := ""
	if input.Name != nil {
		name = *input.Name
	}

	apiKey := ""
	if input.APIKey != nil {
		apiKey = *input.APIKey
	}

	accessKeyID := ""
	if input.AccessKeyID != nil {
		accessKeyID = *input.AccessKeyID
	}

	secretAccessKey := ""
	if input.SecretAccessKey != nil {
		secretAccessKey = *input.SecretAccessKey
	}

	// Validate: must have either API key OR both IAM credentials
	if apiKey == "" && (accessKeyID == "" || secretAccessKey == "") {
		return nil, errors.New("must provide either API key or both Access Key ID and Secret Access Key")
	}

	// Store the key with all credentials
	keyID, err := ks.StoreKey(ctx, tenantSlug, providerDomain, apiKey, name, input.Priority, accessKeyID, secretAccessKey)
	if err != nil {
		return nil, fmt.Errorf("failed to store key: %w", err)
	}

	// Retrieve the stored key to return
	keys, err := ks.ListKeys(ctx, tenantSlug, providerDomain)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve key: %w", err)
	}

	// Find the key we just created
	for _, key := range keys {
		if key.ID == keyID {
			return &model.ProviderAPIKey{
				ID:                 key.ID,
				Provider:           input.Provider,
				Name:               &key.Name,
				KeyPrefix:          key.KeyPrefix,
				CredentialType:     key.CredentialType,
				Priority:           key.Priority,
				Enabled:            key.Enabled,
				HealthScore:        key.HealthScore,
				SuccessCount:       key.SuccessCount,
				FailureCount:       key.FailureCount,
				RateLimitRemaining: key.RateLimitRemaining,
				RateLimitResetAt:   key.RateLimitResetAt,
				RequestCount:       int(key.RequestCount),
				LastUsedAt:         key.LastUsedAt,
				CreatedAt:          key.CreatedAt,
				UpdatedAt:          key.UpdatedAt,
			}, nil
		}
	}

	return nil, errors.New("failed to find created key")
}

// UpdateProviderAPIKey is the resolver for the updateProviderAPIKey field.
func (r *mutationResolver) UpdateProviderAPIKey(ctx context.Context, input model.UpdateProviderAPIKeyInput) (*model.ProviderAPIKey, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	// Get KeySelector
	keySelector := r.Gateway.GetKeySelector()
	if keySelector == nil {
		return nil, errors.New("key selector not available")
	}

	ks, ok := keySelector.(*provider.KeySelector)
	if !ok {
		return nil, errors.New("invalid key selector type")
	}

	// Extract values
	name := ""
	if input.Name != nil {
		name = *input.Name
	}
	priority := 1
	if input.Priority != nil {
		priority = *input.Priority
	}
	enabled := true
	if input.Enabled != nil {
		enabled = *input.Enabled
	}

	// Update the key
	if err := ks.UpdateKey(ctx, tenantSlug, input.ID, name, priority, enabled); err != nil {
		return nil, fmt.Errorf("failed to update key: %w", err)
	}

	// Return minimal response (ideally we'd re-fetch the key, but for simplicity return the input)
	return &model.ProviderAPIKey{
		ID:          input.ID,
		Name:        &name,
		Priority:    priority,
		Enabled:     enabled,
		HealthScore: 1.0, // Placeholder
	}, nil
}

// DeleteProviderAPIKey is the resolver for the deleteProviderAPIKey field.
func (r *mutationResolver) DeleteProviderAPIKey(ctx context.Context, id string) (bool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return false, errors.New("tenant context required")
	}

	// Get KeySelector
	keySelector := r.Gateway.GetKeySelector()
	if keySelector == nil {
		return false, errors.New("key selector not available")
	}

	ks, ok := keySelector.(*provider.KeySelector)
	if !ok {
		return false, errors.New("invalid key selector type")
	}

	// Delete the key
	if err := ks.DeleteKey(ctx, tenantSlug, id); err != nil {
		return false, fmt.Errorf("failed to delete key: %w", err)
	}

	return true, nil
}

// EnableModel is the resolver for the enableModel field.
func (r *mutationResolver) EnableModel(ctx context.Context, modelID string) (*model.Model, error) {
	return &model.Model{ID: modelID, Enabled: true}, nil
}

// DisableModel is the resolver for the disableModel field.
func (r *mutationResolver) DisableModel(ctx context.Context, modelID string) (*model.Model, error) {
	return &model.Model{ID: modelID, Enabled: false}, nil
}

// RefreshProviderModels is the resolver for the refreshProviderModels field.
func (r *mutationResolver) RefreshProviderModels(ctx context.Context, provider model.Provider) (*model.RefreshModelsResult, error) {
	// Convert GraphQL provider enum to domain provider
	domainProvider := domain.Provider(strings.ToLower(string(provider)))

	// Get provider config from database
	providerCfg, err := r.PGStore.GetProviderConfig(ctx, domainProvider)
	if err != nil {
		return nil, fmt.Errorf("failed to get provider config: %w", err)
	}

	if providerCfg == nil {
		return nil, fmt.Errorf("provider %s is not configured", provider)
	}

	if !providerCfg.Enabled {
		return nil, fmt.Errorf("provider %s is not enabled", provider)
	}

	// Single-tenant mode - use "default" as tenant slug
	models, err := r.Gateway.ListProviderModels(ctx, "default", domainProvider, providerCfg)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch models from provider: %w", err)
	}

	// Delete existing models for this provider before saving new ones
	err = r.PGStore.DeleteProviderModels(ctx, string(domainProvider))
	if err != nil {
		return nil, fmt.Errorf("failed to delete existing models: %w", err)
	}

	// Save new models to database
	err = r.PGStore.SaveAvailableModels(ctx, string(domainProvider), models)
	if err != nil {
		return nil, fmt.Errorf("failed to save models to database: %w", err)
	}

	return &model.RefreshModelsResult{
		Success:  true,
		Count:    len(models),
		Message:  fmt.Sprintf("Successfully refreshed %d models from %s", len(models), provider),
		Provider: provider,
	}, nil
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input model.CreateRoleInput) (*model.Role, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	desc := ""
	if input.Description != nil {
		desc = *input.Description
	}

	actor := GetAuditActor(ctx)
	now := time.Now()
	role := &domain.Role{
		ID:             uuid.New().String(),
		Name:           input.Name,
		Description:    desc,
		IsDefault:      input.IsDefault != nil && *input.IsDefault,
		IsSystem:       false,
		CreatedBy:      actor.ID,
		CreatedByEmail: actor.Email,
		CreatedAt:      now,
		UpdatedAt:      now,
	}

	if err := r.PGStore.CreateRole(ctx, role); err != nil {
		// Audit failure
		r.AuditService.LogFailure(ctx, audit.LogEntry{
			TenantSlug:   tenantSlug,
			Action:       domain.AuditActionCreate,
			ResourceType: domain.AuditResourceRole,
			ResourceID:   role.ID,
			ResourceName: role.Name,
			Actor:        GetAuditActor(ctx),
			IPAddress:    GetIPFromContext(ctx),
			UserAgent:    GetUserAgentFromContext(ctx),
		}, err.Error())
		return nil, fmt.Errorf("failed to create role: %w", err)
	}

	// If a policy is provided, create it
	if input.Policy != nil {
		policy := convertInputToDomainPolicy(input.Policy, role.ID)
		if err := r.PGStore.CreateRolePolicy(ctx, policy); err != nil {
			return nil, fmt.Errorf("failed to create role policy: %w", err)
		}
	}

	// Audit success
	r.AuditService.LogSuccess(ctx, audit.LogEntry{
		TenantSlug:   tenantSlug,
		Action:       domain.AuditActionCreate,
		ResourceType: domain.AuditResourceRole,
		ResourceID:   role.ID,
		ResourceName: role.Name,
		Actor:        GetAuditActor(ctx),
		IPAddress:    GetIPFromContext(ctx),
		UserAgent:    GetUserAgentFromContext(ctx),
		NewValue: map[string]any{
			"name":        role.Name,
			"description": role.Description,
			"is_default":  role.IsDefault,
		},
	})

	return &model.Role{
		ID:          role.ID,
		Name:        role.Name,
		Description: &role.Description,
		IsDefault:   role.IsDefault,
		IsSystem:    role.IsSystem,
		CreatedAt:   role.CreatedAt,
		UpdatedAt:   role.UpdatedAt,
	}, nil
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, id string, input model.UpdateRoleInput) (*model.Role, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	// Get existing role
	existingRole, err := r.PGStore.GetRole(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get role: %w", err)
	}
	if existingRole == nil {
		return nil, errors.New("role not found")
	}

	// Update fields
	if input.Name != nil {
		existingRole.Name = *input.Name
	}
	if input.Description != nil {
		existingRole.Description = *input.Description
	}
	if input.IsDefault != nil {
		existingRole.IsDefault = *input.IsDefault
	}
	existingRole.UpdatedAt = time.Now()

	if err := r.PGStore.UpdateRole(ctx, existingRole); err != nil {
		return nil, fmt.Errorf("failed to update role: %w", err)
	}

	return &model.Role{
		ID:          existingRole.ID,
		Name:        existingRole.Name,
		Description: &existingRole.Description,
		IsDefault:   existingRole.IsDefault,
		IsSystem:    existingRole.IsSystem,
		CreatedAt:   existingRole.CreatedAt,
		UpdatedAt:   existingRole.UpdatedAt,
	}, nil
}

// UpdateRolePolicy is the resolver for the updateRolePolicy field.
func (r *mutationResolver) UpdateRolePolicy(ctx context.Context, roleID string, input model.RolePolicyInput) (*model.RolePolicy, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	// Get existing policy for audit
	existingPolicy, _ := r.PGStore.GetRolePolicy(ctx, roleID)
	var oldValue map[string]any
	if existingPolicy != nil {
		oldValue = map[string]any{
			"prompt_policies":    existingPolicy.PromptPolicies,
			"model_restrictions": existingPolicy.ModelRestriction,
			"rate_limits":        existingPolicy.RateLimitPolicy,
		}
	}

	// Get role name for audit
	roleName := roleID
	if role, _ := r.PGStore.GetRole(ctx, roleID); role != nil {
		roleName = role.Name
	}

	// Convert GraphQL input to domain policy
	policy := convertInputToDomainPolicy(&input, roleID)

	// Save to database
	if err := r.PGStore.UpdateRolePolicy(ctx, policy); err != nil {
		r.AuditService.LogFailure(ctx, audit.LogEntry{
			TenantSlug:   tenantSlug,
			Action:       domain.AuditActionUpdate,
			ResourceType: domain.AuditResourcePolicy,
			ResourceID:   roleID,
			ResourceName: roleName,
			Actor:        GetAuditActor(ctx),
			IPAddress:    GetIPFromContext(ctx),
			UserAgent:    GetUserAgentFromContext(ctx),
		}, err.Error())
		return nil, fmt.Errorf("failed to update role policy: %w", err)
	}

	// Retrieve updated policy for response
	updatedPolicy, err := r.PGStore.GetRolePolicy(ctx, roleID)
	if err != nil {
		return nil, fmt.Errorf("failed to get updated policy: %w", err)
	}

	// Audit success
	r.AuditService.LogSuccess(ctx, audit.LogEntry{
		TenantSlug:   tenantSlug,
		Action:       domain.AuditActionUpdate,
		ResourceType: domain.AuditResourcePolicy,
		ResourceID:   roleID,
		ResourceName: roleName,
		Actor:        GetAuditActor(ctx),
		IPAddress:    GetIPFromContext(ctx),
		UserAgent:    GetUserAgentFromContext(ctx),
		OldValue:     oldValue,
		NewValue: map[string]any{
			"prompt_policies":    updatedPolicy.PromptPolicies,
			"model_restrictions": updatedPolicy.ModelRestriction,
			"rate_limits":        updatedPolicy.RateLimitPolicy,
		},
	})

	return convertDomainPolicyToModel(updatedPolicy), nil
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id string) (bool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return false, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return false, errors.New("database not configured")
	}

	// Check if role is a system role
	role, err := r.PGStore.GetRole(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to get role: %w", err)
	}
	if role == nil {
		return false, errors.New("role not found")
	}
	if role.IsSystem {
		return false, errors.New("cannot delete system role")
	}

	if err := r.PGStore.DeleteRole(ctx, id); err != nil {
		return false, fmt.Errorf("failed to delete role: %w", err)
	}

	return true, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.CreateGroupInput) (*model.Group, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	desc := ""
	if input.Description != nil {
		desc = *input.Description
	}

	actor := GetAuditActor(ctx)
	now := time.Now()
	group := &domain.Group{
		ID:             uuid.New().String(),
		Name:           input.Name,
		Description:    desc,
		RoleIDs:        input.RoleIds,
		CreatedBy:      actor.ID,
		CreatedByEmail: actor.Email,
		CreatedAt:      now,
		UpdatedAt:      now,
	}

	if err := r.PGStore.CreateGroup(ctx, group); err != nil {
		return nil, fmt.Errorf("failed to create group: %w", err)
	}

	// Fetch roles for response
	roles := []model.Role{}
	for _, roleID := range group.RoleIDs {
		role, err := r.PGStore.GetRole(ctx, roleID)
		if err == nil && role != nil {
			roles = append(roles, model.Role{
				ID:   role.ID,
				Name: role.Name,
			})
		}
	}

	return &model.Group{
		ID:             group.ID,
		Name:           group.Name,
		Roles:          roles,
		CreatedBy:      &group.CreatedBy,
		CreatedByEmail: &group.CreatedByEmail,
		CreatedAt:      group.CreatedAt,
		UpdatedAt:      group.UpdatedAt,
	}, nil
}

// UpdateGroup is the resolver for the updateGroup field.
func (r *mutationResolver) UpdateGroup(ctx context.Context, id string, input model.UpdateGroupInput) (*model.Group, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	// Get existing group
	existingGroup, err := r.PGStore.GetGroup(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get group: %w", err)
	}
	if existingGroup == nil {
		return nil, errors.New("group not found")
	}

	// Update fields
	if input.Name != nil {
		existingGroup.Name = *input.Name
	}
	if input.Description != nil {
		existingGroup.Description = *input.Description
	}
	if input.RoleIds != nil {
		existingGroup.RoleIDs = input.RoleIds
	}
	existingGroup.UpdatedAt = time.Now()

	if err := r.PGStore.UpdateGroup(ctx, existingGroup); err != nil {
		return nil, fmt.Errorf("failed to update group: %w", err)
	}

	// Fetch roles for response
	roles := []model.Role{}
	for _, roleID := range existingGroup.RoleIDs {
		role, err := r.PGStore.GetRole(ctx, roleID)
		if err == nil && role != nil {
			roles = append(roles, model.Role{
				ID:   role.ID,
				Name: role.Name,
			})
		}
	}

	return &model.Group{
		ID:        existingGroup.ID,
		Name:      existingGroup.Name,
		Roles:     roles,
		CreatedAt: existingGroup.CreatedAt,
		UpdatedAt: existingGroup.UpdatedAt,
	}, nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (bool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return false, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return false, errors.New("database not configured")
	}

	if err := r.PGStore.DeleteGroup(ctx, id); err != nil {
		return false, fmt.Errorf("failed to delete group: %w", err)
	}

	return true, nil
}

// CreateAPIKey is the resolver for the createAPIKey field.
func (r *mutationResolver) CreateAPIKey(ctx context.Context, input model.CreateAPIKeyInput) (*model.APIKeyWithSecret, error) {
	// Get tenant context
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	// Get tenant object for tenant ID
	tenant, ok := ctx.Value("tenant").(*domain.Tenant)
	if !ok || tenant == nil {
		return nil, fmt.Errorf("tenant not found in context")
	}

	// Get tenant store
	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant store: %w", err)
	}

	// Get actor info for audit and createdBy
	actor := GetAuditActor(ctx)

	// Convert input role/group IDs
	roleID := ""
	if input.RoleID != nil {
		roleID = *input.RoleID
	}
	groupID := ""
	if input.GroupID != nil {
		groupID = *input.GroupID
	}

	// Validate role or group assignment
	if roleID == "" && groupID == "" {
		return nil, errors.New("either roleId or groupId must be provided")
	}
	if roleID != "" && groupID != "" {
		return nil, errors.New("cannot assign both roleId and groupId to an API key")
	}

	// Parse expiry date if provided
	var expiresAt *time.Time
	if input.ExpiresAt != nil {
		expiresAt = input.ExpiresAt
	}

	// Create API key in tenant database
	apiKey, fullKey, err := tenantStore.CreateAPIKey(ctx, input.Name, roleID, groupID, []string{}, expiresAt)
	if err != nil {
		r.AuditService.LogFailure(ctx, audit.LogEntry{
			TenantSlug:   tenantSlug,
			Action:       domain.AuditActionCreate,
			ResourceType: domain.AuditResourceAPIKey,
			ResourceID:   "",
			ResourceName: input.Name,
			Actor:        actor,
			IPAddress:    GetIPFromContext(ctx),
			UserAgent:    GetUserAgentFromContext(ctx),
		}, err.Error())
		return nil, fmt.Errorf("failed to create API key: %w", err)
	}

	// Update API key with creator info
	tenantStore.UpdateAPIKeyCreator(ctx, apiKey.ID, actor.ID, actor.Email)

	// Load role/group info for response
	var role *model.Role
	var group *model.Group
	var roleName, groupName string

	if roleID != "" {
		domainRole, err := r.PGStore.GetRole(ctx, roleID)
		if err == nil && domainRole != nil {
			role = &model.Role{
				ID:   domainRole.ID,
				Name: domainRole.Name,
			}
			roleName = domainRole.Name
		}
	}

	if groupID != "" {
		domainGroup, err := r.PGStore.GetGroup(ctx, groupID)
		if err == nil && domainGroup != nil {
			group = &model.Group{
				ID:   domainGroup.ID,
				Name: domainGroup.Name,
			}
			groupName = domainGroup.Name
		}
	}

	// Audit success
	r.AuditService.LogSuccess(ctx, audit.LogEntry{
		TenantSlug:   tenantSlug,
		Action:       domain.AuditActionCreate,
		ResourceType: domain.AuditResourceAPIKey,
		ResourceID:   apiKey.ID,
		ResourceName: apiKey.Name,
		Actor:        actor,
		IPAddress:    GetIPFromContext(ctx),
		UserAgent:    GetUserAgentFromContext(ctx),
		NewValue: map[string]any{
			"name":       apiKey.Name,
			"key_prefix": apiKey.KeyPrefix,
			"role":       roleName,
			"group":      groupName,
			"expires_at": expiresAt,
		},
	})

	return &model.APIKeyWithSecret{
		APIKey: &model.APIKey{
			ID:             apiKey.ID,
			Name:           apiKey.Name,
			KeyPrefix:      apiKey.KeyPrefix,
			Role:           role,
			Group:          group,
			CreatedAt:      apiKey.CreatedAt,
			CreatedBy:      &actor.ID,
			CreatedByEmail: &actor.Email,
			ExpiresAt:      expiresAt,
		},
		Secret: fullKey, // Only shown once!
	}, nil
}

// UpdateAPIKey is the resolver for the updateAPIKey field.
func (r *mutationResolver) UpdateAPIKey(ctx context.Context, id string, input model.UpdateAPIKeyInput) (*model.APIKey, error) {
	name := ""
	if input.Name != nil {
		name = *input.Name
	}
	return &model.APIKey{
		ID:        id,
		Name:      name,
		KeyPrefix: "mg_",
		CreatedAt: time.Now(),
	}, nil
}

// DeleteAPIKey is the resolver for the deleteAPIKey field.
func (r *mutationResolver) DeleteAPIKey(ctx context.Context, id string) (bool, error) {
	// Get tenant context
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return false, errors.New("tenant context required")
	}

	actor := GetAuditActor(ctx)

	// Get tenant store
	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return false, fmt.Errorf("failed to get tenant store: %w", err)
	}

	// Get API key to find its hash (needed for admin registry deletion)
	apiKey, err := tenantStore.GetAPIKey(ctx, id)
	if err != nil {
		return false, fmt.Errorf("API key not found: %w", err)
	}

	// Delete from tenant database first
	err = tenantStore.DeleteAPIKey(ctx, id)
	if err != nil {
		r.AuditService.LogFailure(ctx, audit.LogEntry{
			TenantSlug:   tenantSlug,
			Action:       domain.AuditActionDelete,
			ResourceType: domain.AuditResourceAPIKey,
			ResourceID:   id,
			ResourceName: apiKey.Name,
			Actor:        actor,
			IPAddress:    GetIPFromContext(ctx),
			UserAgent:    GetUserAgentFromContext(ctx),
		}, err.Error())
		return false, fmt.Errorf("failed to delete API key: %w", err)
	}

	// Audit success
	r.AuditService.LogSuccess(ctx, audit.LogEntry{
		TenantSlug:   tenantSlug,
		Action:       domain.AuditActionDelete,
		ResourceType: domain.AuditResourceAPIKey,
		ResourceID:   id,
		ResourceName: apiKey.Name,
		Actor:        actor,
		IPAddress:    GetIPFromContext(ctx),
		UserAgent:    GetUserAgentFromContext(ctx),
		OldValue: map[string]any{
			"name":       apiKey.Name,
			"key_prefix": apiKey.KeyPrefix,
		},
	})

	return true, nil
}

// RevokeAPIKey is the resolver for the revokeAPIKey field.
func (r *mutationResolver) RevokeAPIKey(ctx context.Context, id string) (bool, error) {
	// Get tenant context
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return false, errors.New("tenant context required")
	}

	// Get tenant store
	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return false, fmt.Errorf("failed to get tenant store: %w", err)
	}

	// Revoke in tenant database
	err = tenantStore.RevokeAPIKey(ctx, id, "Revoked by user")
	if err != nil {
		return false, fmt.Errorf("failed to revoke API key: %w", err)
	}

	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, email string, name string, password string, role string) (*model.User, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("getting tenant store: %w", err)
	}

	actor := GetAuditActor(ctx)

	user, err := tenantStore.CreateUser(ctx, email, password, name, role, actor.ID, actor.Email)
	if err != nil {
		r.AuditService.LogFailure(ctx, audit.LogEntry{
			TenantSlug:   tenantSlug,
			Action:       domain.AuditActionCreate,
			ResourceType: domain.AuditResourceUser,
			ResourceID:   "",
			ResourceName: email,
			Actor:        actor,
			IPAddress:    GetIPFromContext(ctx),
			UserAgent:    GetUserAgentFromContext(ctx),
		}, err.Error())
		return nil, fmt.Errorf("creating user: %w", err)
	}

	// Audit success
	r.AuditService.LogSuccess(ctx, audit.LogEntry{
		TenantSlug:   tenantSlug,
		Action:       domain.AuditActionCreate,
		ResourceType: domain.AuditResourceUser,
		ResourceID:   user.ID,
		ResourceName: user.Email,
		Actor:        actor,
		IPAddress:    GetIPFromContext(ctx),
		UserAgent:    GetUserAgentFromContext(ctx),
		NewValue: map[string]any{
			"email": user.Email,
			"name":  user.Name,
			"role":  user.Role,
		},
	})

	result := convertTenantUserToModel(user)
	return &result, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, name *string, role *string) (*model.User, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("getting tenant store: %w", err)
	}

	actor := GetAuditActor(ctx)

	// Get existing user for audit
	existingUser, _ := tenantStore.GetUser(ctx, id)
	var oldValue map[string]any
	if existingUser != nil {
		oldValue = map[string]any{
			"name": existingUser.Name,
			"role": existingUser.Role,
		}
	}

	user, err := tenantStore.UpdateUser(ctx, id, name, role, nil)
	if err != nil {
		r.AuditService.LogFailure(ctx, audit.LogEntry{
			TenantSlug:   tenantSlug,
			Action:       domain.AuditActionUpdate,
			ResourceType: domain.AuditResourceUser,
			ResourceID:   id,
			ResourceName: existingUser.Email,
			Actor:        actor,
			IPAddress:    GetIPFromContext(ctx),
			UserAgent:    GetUserAgentFromContext(ctx),
		}, err.Error())
		return nil, fmt.Errorf("updating user: %w", err)
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	// Audit success
	r.AuditService.LogSuccess(ctx, audit.LogEntry{
		TenantSlug:   tenantSlug,
		Action:       domain.AuditActionUpdate,
		ResourceType: domain.AuditResourceUser,
		ResourceID:   user.ID,
		ResourceName: user.Email,
		Actor:        actor,
		IPAddress:    GetIPFromContext(ctx),
		UserAgent:    GetUserAgentFromContext(ctx),
		OldValue:     oldValue,
		NewValue: map[string]any{
			"name": user.Name,
			"role": user.Role,
		},
	})

	result := convertTenantUserToModel(user)
	return &result, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return false, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return false, fmt.Errorf("getting tenant store: %w", err)
	}

	actor := GetAuditActor(ctx)

	// Get user for audit
	user, _ := tenantStore.GetUser(ctx, id)
	var userName string
	if user != nil {
		userName = user.Email
	}

	err = tenantStore.DeleteUser(ctx, id)
	if err != nil {
		r.AuditService.LogFailure(ctx, audit.LogEntry{
			TenantSlug:   tenantSlug,
			Action:       domain.AuditActionDelete,
			ResourceType: domain.AuditResourceUser,
			ResourceID:   id,
			ResourceName: userName,
			Actor:        actor,
			IPAddress:    GetIPFromContext(ctx),
			UserAgent:    GetUserAgentFromContext(ctx),
		}, err.Error())
		return false, fmt.Errorf("deleting user: %w", err)
	}

	// Audit success
	r.AuditService.LogSuccess(ctx, audit.LogEntry{
		TenantSlug:   tenantSlug,
		Action:       domain.AuditActionDelete,
		ResourceType: domain.AuditResourceUser,
		ResourceID:   id,
		ResourceName: userName,
		Actor:        actor,
		IPAddress:    GetIPFromContext(ctx),
		UserAgent:    GetUserAgentFromContext(ctx),
		OldValue: map[string]any{
			"email": userName,
		},
	})

	return true, nil
}

// CreateBudgetAlert is the resolver for the createBudgetAlert field.
func (r *mutationResolver) CreateBudgetAlert(ctx context.Context, input model.CreateBudgetAlertInput) (*model.BudgetAlert, error) {
	enabled := true
	if input.Enabled != nil {
		enabled = *input.Enabled
	}
	return &model.BudgetAlert{
		ID:            uuid.New().String(),
		Name:          input.Name,
		Type:          input.Type,
		Threshold:     input.Threshold,
		ThresholdType: input.ThresholdType,
		Period:        input.Period,
		Enabled:       enabled,
		CreatedAt:     time.Now(),
	}, nil
}

// UpdateBudgetAlert is the resolver for the updateBudgetAlert field.
func (r *mutationResolver) UpdateBudgetAlert(ctx context.Context, id string, input model.UpdateBudgetAlertInput) (*model.BudgetAlert, error) {
	name := ""
	if input.Name != nil {
		name = *input.Name
	}
	threshold := 0.0
	if input.Threshold != nil {
		threshold = *input.Threshold
	}
	enabled := true
	if input.Enabled != nil {
		enabled = *input.Enabled
	}
	return &model.BudgetAlert{
		ID:        id,
		Name:      name,
		Threshold: threshold,
		Enabled:   enabled,
		CreatedAt: time.Now(),
	}, nil
}

// DeleteBudgetAlert is the resolver for the deleteBudgetAlert field.
func (r *mutationResolver) DeleteBudgetAlert(ctx context.Context, id string) (bool, error) {
	return true, nil
}

// SetToolPermission is the resolver for the setToolPermission field.
func (r *mutationResolver) SetToolPermission(ctx context.Context, input model.SetToolPermissionInput) (*model.ToolRolePermission, error) {
	return r.SetToolPermissionImpl(ctx, input)
}

// SetToolPermissionsBulk is the resolver for the setToolPermissionsBulk field.
func (r *mutationResolver) SetToolPermissionsBulk(ctx context.Context, input model.SetToolPermissionsBulkInput) ([]model.ToolRolePermission, error) {
	return r.SetToolPermissionsBulkImpl(ctx, input)
}

// ApproveAllPendingTools is the resolver for the approveAllPendingTools field.
func (r *mutationResolver) ApproveAllPendingTools(ctx context.Context, roleID string) (int, error) {
	return r.ApproveAllPendingToolsImpl(ctx, roleID)
}

// DenyAllPendingTools is the resolver for the denyAllPendingTools field.
func (r *mutationResolver) DenyAllPendingTools(ctx context.Context, roleID string) (int, error) {
	return r.DenyAllPendingToolsImpl(ctx, roleID)
}

// RemoveAllPendingTools is the resolver for the removeAllPendingTools field.
func (r *mutationResolver) RemoveAllPendingTools(ctx context.Context, roleID string) (int, error) {
	return r.RemoveAllPendingToolsImpl(ctx, roleID)
}

// DeleteDiscoveredTool is the resolver for the deleteDiscoveredTool field.
func (r *mutationResolver) DeleteDiscoveredTool(ctx context.Context, id string) (bool, error) {
	return r.DeleteDiscoveredToolImpl(ctx, id)
}

// CreateMCPServer creates a new MCP server
func (r *mutationResolver) CreateMCPServer(ctx context.Context, input model.CreateMCPServerInput) (*model.MCPServer, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	actorID, _, _ := getActorInfoFromContext(ctx)

	// Import the mcp package to access SanitizeServerName
	serverSlug := mcp.SanitizeServerName(input.Name)

	server := &domain.MCPServer{
		Name:                input.Name,
		Slug:                serverSlug,
		Description:         ptrToString(input.Description),
		ServerType:          graphqlToMCPServerType(input.ServerType),
		Endpoint:            input.Endpoint,
		AuthType:            graphqlToMCPAuthType(input.AuthType),
		Status:              domain.MCPStatusPending,
		AutoSync:            true,
		SyncIntervalMinutes: 60,
		CreatedBy:           actorID,
	}

	if input.Arguments != nil {
		server.Arguments = input.Arguments
	}
	if input.Environment != nil {
		server.Environment = make(map[string]string)
		for k, v := range input.Environment {
			if s, ok := v.(string); ok {
				server.Environment[k] = s
			}
		}
	}
	if input.AuthConfig != nil {
		server.AuthConfig = inputToMCPAuthConfig(input.AuthConfig)
	}
	if input.Tags != nil {
		server.Tags = input.Tags
	}
	if input.AutoSync != nil {
		server.AutoSync = *input.AutoSync
	}
	if input.SyncIntervalMinutes != nil {
		server.SyncIntervalMinutes = *input.SyncIntervalMinutes
	}

	if err := store.CreateMCPServer(ctx, server); err != nil {
		return nil, err
	}

	return domainToMCPServerModel(server), nil
}

// UpdateMCPServer updates an MCP server
func (r *mutationResolver) UpdateMCPServer(ctx context.Context, id string, input model.UpdateMCPServerInput) (*model.MCPServer, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	server, err := store.GetMCPServer(ctx, id)
	if err != nil {
		return nil, err
	}
	if server == nil {
		return nil, fmt.Errorf("MCP server not found: %s", id)
	}

	if input.Name != nil {
		server.Name = *input.Name
		server.Slug = mcp.SanitizeServerName(*input.Name)
	}
	if input.Description != nil {
		server.Description = *input.Description
	}
	if input.Endpoint != nil {
		server.Endpoint = *input.Endpoint
	}
	if input.AuthType != nil {
		server.AuthType = domain.MCPAuthType(*input.AuthType)
	}
	if input.AuthConfig != nil {
		// Preserve existing auth config and merge with new values
		existingAuthConfig := server.AuthConfig
		newAuthConfig := inputToMCPAuthConfig(input.AuthConfig)

		// Preserve existing sensitive values if new values are masked ("***")
		if newAuthConfig.APIKey == "" && existingAuthConfig.APIKey != "" {
			newAuthConfig.APIKey = existingAuthConfig.APIKey
		}
		if newAuthConfig.BearerToken == "" && existingAuthConfig.BearerToken != "" {
			newAuthConfig.BearerToken = existingAuthConfig.BearerToken
		}
		if newAuthConfig.ClientSecret == "" && existingAuthConfig.ClientSecret != "" {
			newAuthConfig.ClientSecret = existingAuthConfig.ClientSecret
		}
		if newAuthConfig.Password == "" && existingAuthConfig.Password != "" {
			newAuthConfig.Password = existingAuthConfig.Password
		}
		if newAuthConfig.ClientKey == "" && existingAuthConfig.ClientKey != "" {
			newAuthConfig.ClientKey = existingAuthConfig.ClientKey
		}

		server.AuthConfig = newAuthConfig
	}
	if input.Tags != nil {
		server.Tags = input.Tags
	}
	if input.AutoSync != nil {
		server.AutoSync = *input.AutoSync
	}
	if input.SyncIntervalMinutes != nil {
		server.SyncIntervalMinutes = *input.SyncIntervalMinutes
	}

	if err := store.UpdateMCPServer(ctx, server); err != nil {
		return nil, err
	}

	return domainToMCPServerModel(server), nil
}

// DeleteMCPServer deletes an MCP server
func (r *mutationResolver) DeleteMCPServer(ctx context.Context, id string) (bool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return false, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return false, err
	}

	// Disconnect if connected
	if r.mcpGateway != nil {
		r.mcpGateway.Disconnect(id)
	}

	if err := store.DeleteMCPServer(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// ConnectMCPServer connects to an MCP server
func (r *mutationResolver) ConnectMCPServer(ctx context.Context, id string) (*model.MCPServer, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	server, err := store.GetMCPServer(ctx, id)
	if err != nil {
		return nil, err
	}
	if server == nil {
		return nil, fmt.Errorf("MCP server not found: %s", id)
	}

	if r.mcpGateway == nil {
		return nil, fmt.Errorf("MCP gateway not configured")
	}

	if err := r.mcpGateway.Connect(ctx, server); err != nil {
		server.Status = domain.MCPStatusError
		server.ErrorMessage = err.Error()
		store.UpdateMCPServer(ctx, server)
		return nil, err
	}

	server.Status = domain.MCPStatusConnected
	server.ErrorMessage = "" // Clear any previous error
	server.RetryCount = 0    // Reset retry count
	now := time.Now()
	server.LastHealthCheck = &now
	store.UpdateMCPServer(ctx, server)

	return domainToMCPServerModel(server), nil
}

// DisconnectMCPServer disconnects from an MCP server
func (r *mutationResolver) DisconnectMCPServer(ctx context.Context, id string) (*model.MCPServer, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	server, err := store.GetMCPServer(ctx, id)
	if err != nil {
		return nil, err
	}
	if server == nil {
		return nil, fmt.Errorf("MCP server not found: %s", id)
	}

	if r.mcpGateway != nil {
		r.mcpGateway.Disconnect(id)
	}

	server.Status = domain.MCPStatusDisconnected
	store.UpdateMCPServer(ctx, server)

	return domainToMCPServerModel(server), nil
}

// SyncMCPServer syncs tools from an MCP server
func (r *mutationResolver) SyncMCPServer(ctx context.Context, id string) (*model.MCPServerVersion, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	server, err := store.GetMCPServer(ctx, id)
	if err != nil {
		return nil, err
	}
	if server == nil {
		return nil, fmt.Errorf("MCP server not found: %s", id)
	}

	if r.mcpGateway == nil {
		return nil, fmt.Errorf("MCP gateway not configured")
	}

	version, err := r.mcpGateway.SyncServer(ctx, tenantSlug, server)
	if err != nil {
		return nil, err
	}

	return domainToMCPServerVersionModel(version), nil
}

// RollbackMCPServer rolls back a server to a previous version
func (r *mutationResolver) RollbackMCPServer(ctx context.Context, serverID string, versionID string) (*model.MCPServer, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	// Get the version
	version, err := store.GetMCPServerVersion(ctx, versionID)
	if err != nil {
		return nil, err
	}
	if version == nil {
		return nil, fmt.Errorf("version not found: %s", versionID)
	}

	// Delete current tools
	if err := store.DeleteMCPToolsByServer(ctx, serverID); err != nil {
		return nil, err
	}

	// Restore tools from version
	for _, tool := range version.ToolDefinitions {
		t := tool // copy
		t.ServerID = serverID
		if err := store.UpsertMCPTool(ctx, &t); err != nil {
			return nil, err
		}
	}

	// Update server version
	server, err := store.GetMCPServer(ctx, serverID)
	if err != nil {
		return nil, err
	}
	server.Version = version.Version
	store.UpdateMCPServer(ctx, server)

	return domainToMCPServerModel(server), nil
}

// SetMCPPermission sets a permission for an MCP tool or server
func (r *mutationResolver) SetMCPPermission(ctx context.Context, input model.SetMCPPermissionInput) (*model.MCPToolPermission, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	actorID, actorEmail, _ := getActorInfoFromContext(ctx)
	now := time.Now()

	perm := &domain.MCPToolPermission{
		RoleID:         input.RoleID,
		ServerID:       input.ServerID,
		ToolID:         input.ToolID,
		Visibility:     domain.MCPToolVisibility(input.Visibility),
		DecidedBy:      actorID,
		DecidedByEmail: actorEmail,
		DecidedAt:      &now,
	}

	if input.Reason != nil {
		perm.DecisionReason = *input.Reason
	}

	if err := store.SetMCPToolPermission(ctx, perm); err != nil {
		return nil, err
	}

	// Sync to role_tools if visibility is ALLOW or SEARCH
	if perm.Visibility == domain.MCPVisibilityAllow || perm.Visibility == domain.MCPVisibilitySearch {
		if err := r.syncMCPToolToRoleTools(ctx, store, perm.RoleID, perm.ToolID, actorID); err != nil {
			slog.Warn("Failed to sync MCP tool to role_tools",
				"tool_id", perm.ToolID,
				"role_id", perm.RoleID,
				"error", err,
			)
			// Don't fail the main operation
		}
	}

	return domainToMCPToolPermissionModel(perm), nil
}

// BulkSetMCPVisibility sets visibility for all tools in a server
func (r *mutationResolver) BulkSetMCPVisibility(ctx context.Context, roleID string, serverID string, visibility model.MCPToolVisibility) (int, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return 0, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return 0, err
	}

	actorID, actorEmail, _ := getActorInfoFromContext(ctx)

	count, err := store.BulkSetMCPVisibility(ctx, roleID, serverID, domain.MCPToolVisibility(visibility), actorID, actorEmail)
	if err != nil {
		return 0, err
	}

	// Sync to role_tools if visibility is ALLOW or SEARCH
	if visibility == model.MCPToolVisibilityAllow || visibility == model.MCPToolVisibilitySearch {
		// Get all tools for this server
		tools, err := store.ListMCPTools(ctx, serverID)
		if err != nil {
			slog.Warn("Failed to list MCP tools for bulk sync",
				"server_id", serverID,
				"error", err,
			)
		} else {
			// Sync each tool (don't fail bulk operation on sync errors)
			for _, tool := range tools {
				if err := r.syncMCPToolToRoleTools(ctx, store, roleID, tool.ID, actorID); err != nil {
					slog.Warn("Failed to sync MCP tool in bulk operation",
						"tool_id", tool.ID,
						"tool_name", tool.Name,
						"error", err,
					)
				}
			}
		}
	}

	return count, nil
}

// AddToolExample adds an example to a tool
func (r *mutationResolver) AddToolExample(ctx context.Context, toolID string, example map[string]any) (*model.MCPTool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	tool, err := store.GetMCPTool(ctx, toolID)
	if err != nil {
		return nil, err
	}
	if tool == nil {
		return nil, fmt.Errorf("tool not found: %s", toolID)
	}

	// Add example
	tool.InputExamples = append(tool.InputExamples, example)

	if err := store.UpsertMCPTool(ctx, tool); err != nil {
		return nil, err
	}

	return domainToMCPToolModel(tool), nil
}

// RemoveToolExample removes an example from a tool
func (r *mutationResolver) RemoveToolExample(ctx context.Context, toolID string, exampleIndex int) (*model.MCPTool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	tool, err := store.GetMCPTool(ctx, toolID)
	if err != nil {
		return nil, err
	}
	if tool == nil {
		return nil, fmt.Errorf("tool not found: %s", toolID)
	}

	// Remove example
	if exampleIndex >= 0 && exampleIndex < len(tool.InputExamples) {
		tool.InputExamples = append(tool.InputExamples[:exampleIndex], tool.InputExamples[exampleIndex+1:]...)
	}

	if err := store.UpsertMCPTool(ctx, tool); err != nil {
		return nil, err
	}

	return domainToMCPToolModel(tool), nil
}

// APIKeys is the resolver for the apiKeys field.
func (r *providerConfigResolver) APIKeys(ctx context.Context, obj *model.ProviderConfig) ([]model.ProviderAPIKey, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return []model.ProviderAPIKey{}, nil
	}

	// Get KeySelector from Gateway
	keySelector := r.Gateway.GetKeySelector()
	if keySelector == nil {
		return []model.ProviderAPIKey{}, nil
	}

	// Convert provider enum to domain type
	providerDomain := domain.Provider(strings.ToLower(string(obj.Provider)))

	// Type assert KeySelector
	ks, ok := keySelector.(*provider.KeySelector)
	if !ok {
		return []model.ProviderAPIKey{}, nil
	}

	// Get keys from KeySelector
	keys, err := ks.ListKeys(ctx, tenantSlug, providerDomain)
	if err != nil {
		return []model.ProviderAPIKey{}, nil
	}

	// Convert to GraphQL model
	result := make([]model.ProviderAPIKey, len(keys))
	for i, key := range keys {
		result[i] = model.ProviderAPIKey{
			ID:                 key.ID,
			Provider:           obj.Provider,
			Name:               &key.Name,
			KeyPrefix:          key.KeyPrefix,
			CredentialType:     key.CredentialType,
			Priority:           key.Priority,
			Enabled:            key.Enabled,
			HealthScore:        key.HealthScore,
			SuccessCount:       key.SuccessCount,
			FailureCount:       key.FailureCount,
			RateLimitRemaining: key.RateLimitRemaining,
			RateLimitResetAt:   key.RateLimitResetAt,
			RequestCount:       int(key.RequestCount),
			LastUsedAt:         key.LastUsedAt,
			CreatedAt:          key.CreatedAt,
			UpdatedAt:          key.UpdatedAt,
		}
	}

	return result, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user from context (set by auth middleware)
	user, ok := ctx.Value(ContextKeyUser).(*domain.User)
	if !ok || user == nil {
		return nil, errors.New("unauthorized: not logged in")
	}

	return &model.User{
		ID:        user.ID,
		Email:     user.Email,
		Name:      user.Name,
		Role:      string(user.Role),
		Status:    string(user.Status),
		CreatedAt: user.CreatedAt,
	}, nil
}

// Tenants is the resolver for the tenants field.
// Not supported in single-tenant mode - returns default tenant only
func (r *queryResolver) Tenants(ctx context.Context) ([]model.Tenant, error) {
	// Return the single default tenant
	defaultLimits := domain.GetPlanLimits(domain.TenantTierEnterprise, nil)
	return []model.Tenant{{
		ID:         "default",
		Name:       "Default",
		Slug:       "default",
		Email:      "admin@modelgate.local",
		Status:     model.TenantStatusActive,
		Tier:       model.TenantTierEnterprise,
		PlanLimits: convertDomainPlanLimitsToModel(defaultLimits),
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}}, nil
}

// Tenant is the resolver for the tenant field.
// Returns the default tenant in single-tenant mode
func (r *queryResolver) Tenant(ctx context.Context, id string) (*model.Tenant, error) {
	defaultLimits := domain.GetPlanLimits(domain.TenantTierEnterprise, nil)
	return &model.Tenant{
		ID:         "default",
		Name:       "Default",
		Slug:       "default",
		Email:      "admin@modelgate.local",
		Status:     model.TenantStatusActive,
		Tier:       model.TenantTierEnterprise,
		PlanLimits: convertDomainPlanLimitsToModel(defaultLimits),
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}, nil
}

// TenantBySlug is the resolver for the tenantBySlug field.
// Returns the default tenant in single-tenant mode
func (r *queryResolver) TenantBySlug(ctx context.Context, slug string) (*model.Tenant, error) {
	defaultLimits := domain.GetPlanLimits(domain.TenantTierEnterprise, nil)
	return &model.Tenant{
		ID:         "default",
		Name:       "Default",
		Slug:       "default",
		Email:      "admin@modelgate.local",
		Status:     model.TenantStatusActive,
		Tier:       model.TenantTierEnterprise,
		PlanLimits: convertDomainPlanLimitsToModel(defaultLimits),
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}, nil
}

// AdminStats is the resolver for the adminStats field.
func (r *queryResolver) AdminStats(ctx context.Context) (*model.TenantStats, error) {
	return &model.TenantStats{
		TotalRequests: 0,
		TotalTokens:   0,
		TotalCostUsd:  0,
		ActiveAPIKeys: 0,
		ActiveUsers:   0,
	}, nil
}

// RegistrationRequests is the resolver for the registrationRequests field.
// Not supported in single-tenant mode
func (r *queryResolver) RegistrationRequests(ctx context.Context, status *string) ([]model.RegistrationRequest, error) {
	return []model.RegistrationRequest{}, nil
}

// RegistrationRequest is the resolver for the registrationRequest field.
// Not supported in single-tenant mode
func (r *queryResolver) RegistrationRequest(ctx context.Context, id string) (*model.RegistrationRequest, error) {
	return nil, errors.New("registration requests not supported in single-tenant mode")
}

// Providers is the resolver for the providers field.
func (r *queryResolver) Providers(ctx context.Context) ([]model.ProviderConfig, error) {
	tenantSlug := GetTenantFromContext(ctx)

	// Get tenant tier for plan ceiling
	var tenantTier domain.TenantTier = domain.TenantTierStarter
	if tenantSlug != "" && r.PGStore != nil {
		tenant, err := r.PGStore.GetTenantBySlug(ctx, tenantSlug)
		if err == nil && tenant != nil {
			tenantTier = tenant.Tier
		}
	}
	planCeiling := getPlanCeiling(tenantTier)
	defaultConnSettings := convertDomainConnectionSettingsToModel(domain.DefaultConnectionSettings())

	// Default providers list (all available providers)
	allProviders := []model.Provider{
		model.ProviderOpenai,
		model.ProviderAnthropic,
		model.ProviderGemini,
		model.ProviderBedrock,
		model.ProviderAzureOpenai,
		model.ProviderOllama,
		model.ProviderGroq,
		model.ProviderMistral,
		model.ProviderTogether,
		model.ProviderCohere,
	}

	// Start with all providers disabled
	providerMap := make(map[model.Provider]*model.ProviderConfig)
	for _, p := range allProviders {
		providerMap[p] = &model.ProviderConfig{
			Provider:           p,
			Enabled:            false,
			HasAPIKey:          false,
			HasAccessKeys:      false,
			ConnectionSettings: defaultConnSettings,
			PlanCeiling:        planCeiling,
		}
	}

	// If we have a tenant, fetch their configured providers
	if tenantSlug != "" && r.PGStore != nil {
		configs, err := r.PGStore.ListProviderConfigs(ctx)
		if err == nil && configs != nil {
			for _, cfg := range configs {
				// Convert lowercase database value to uppercase GraphQL enum
				p := model.Provider(strings.ToUpper(string(cfg.Provider)))
				if pc, ok := providerMap[p]; ok {
					pc.Enabled = cfg.Enabled
					pc.HasAPIKey = cfg.APIKey != ""

					// Check for AWS IAM credentials (Access Key + Secret Key)
					hasAccessKeys := cfg.AccessKeyID != "" && cfg.SecretAccessKey != ""
					pc.HasAccessKeys = hasAccessKeys

					// Determine streaming mode for Bedrock
					if p == model.ProviderBedrock {
						if hasAccessKeys {
							streamingMode := "true_streaming"
							pc.StreamingMode = &streamingMode
						} else if cfg.APIKey != "" {
							streamingMode := "simulated_streaming"
							pc.StreamingMode = &streamingMode
						}
					}

					if cfg.BaseURL != "" {
						pc.BaseURL = &cfg.BaseURL
					}
					if cfg.Region != "" {
						pc.Region = &cfg.Region
					}
					if cfg.ResourceName != "" {
						pc.ResourceName = &cfg.ResourceName
					}
					if cfg.APIVersion != "" {
						pc.APIVersion = &cfg.APIVersion
					}
					if cfg.RegionPrefix != "" {
						pc.RegionPrefix = &cfg.RegionPrefix
					}
					if cfg.ModelsURL != "" {
						pc.ModelsURL = &cfg.ModelsURL
					}

					// Include connection settings
					pc.ConnectionSettings = convertDomainConnectionSettingsToModel(cfg.ConnectionSettings)
				}
			}
		}
	}

	// Convert map to slice
	result := make([]model.ProviderConfig, 0, len(allProviders))
	for _, p := range allProviders {
		result = append(result, *providerMap[p])
	}
	return result, nil
}

// Models is the resolver for the models field.
func (r *queryResolver) Models(ctx context.Context) ([]model.Model, error) {
	// Get tenant from context
	tenant, ok := ctx.Value("tenant").(*domain.Tenant)
	if !ok || tenant == nil {
		return []model.Model{}, nil
	}

	tenantSlug, _ := tenant.Metadata["slug"]
	if tenantSlug == "" {
		return []model.Model{}, nil
	}

	// Fetch models from database
	dbModels, err := r.PGStore.ListAvailableModels(ctx, "")
	if err != nil {
		log.Printf("Failed to list available models: %v", err)
		return []model.Model{}, nil
	}

	// Convert to GraphQL model
	result := make([]model.Model, 0, len(dbModels))
	for _, m := range dbModels {
		result = append(result, model.Model{
			ID:                m.ModelID,
			Name:              m.ModelName,
			Provider:          model.Provider(strings.ToUpper(m.Provider)),
			Enabled:           m.IsAvailable,
			SupportsTools:     m.SupportsTools,
			SupportsStreaming: m.SupportsStreaming,
			ContextLimit:      m.ContextWindow,
			InputCostPer1m:    m.InputCostPer1M,
			OutputCostPer1m:   m.OutputCostPer1M,
		})
	}

	return result, nil
}

// AvailableModels is the resolver for the availableModels field.
func (r *queryResolver) AvailableModels(ctx context.Context) ([]model.Model, error) {
	return r.Models(ctx)
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]model.Role, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	roles, err := r.PGStore.ListRoles(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list roles: %w", err)
	}

	result := make([]model.Role, len(roles))
	for i, role := range roles {
		// Fetch policy for this role
		policy, err := r.PGStore.GetRolePolicy(ctx, role.ID)
		var policyModel *model.RolePolicy
		if err == nil && policy != nil {
			policyModel = convertDomainPolicyToModel(policy)
		}

		result[i] = model.Role{
			ID:          role.ID,
			Name:        role.Name,
			Description: &role.Description,
			IsDefault:   role.IsDefault,
			IsSystem:    role.IsSystem,
			Policy:      policyModel,
			CreatedAt:   role.CreatedAt,
			UpdatedAt:   role.UpdatedAt,
		}
		if role.CreatedBy != "" {
			result[i].CreatedBy = &role.CreatedBy
		}
		if role.CreatedByEmail != "" {
			result[i].CreatedByEmail = &role.CreatedByEmail
		}
	}

	return result, nil
}

// Role is the resolver for the role field.
func (r *queryResolver) Role(ctx context.Context, id string) (*model.Role, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	role, err := r.PGStore.GetRole(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get role: %w", err)
	}
	if role == nil {
		return nil, fmt.Errorf("role not found")
	}

	// Fetch policy for this role
	policy, err := r.PGStore.GetRolePolicy(ctx, role.ID)
	var policyModel *model.RolePolicy
	if err == nil && policy != nil {
		policyModel = convertDomainPolicyToModel(policy)
	}

	return &model.Role{
		ID:          role.ID,
		Name:        role.Name,
		Description: &role.Description,
		IsDefault:   role.IsDefault,
		IsSystem:    role.IsSystem,
		Policy:      policyModel,
		CreatedAt:   role.CreatedAt,
		UpdatedAt:   role.UpdatedAt,
	}, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context) ([]model.Group, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	groups, err := r.PGStore.ListGroups(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list groups: %w", err)
	}

	result := make([]model.Group, len(groups))
	for i, group := range groups {
		// Fetch roles for this group
		roles := []model.Role{}
		for _, roleID := range group.RoleIDs {
			role, err := r.PGStore.GetRole(ctx, roleID)
			if err == nil && role != nil {
				roles = append(roles, model.Role{
					ID:          role.ID,
					Name:        role.Name,
					Description: &role.Description,
					IsDefault:   role.IsDefault,
					IsSystem:    role.IsSystem,
					CreatedAt:   role.CreatedAt,
					UpdatedAt:   role.UpdatedAt,
				})
			}
		}

		result[i] = model.Group{
			ID:          group.ID,
			Name:        group.Name,
			Description: &group.Description,
			Roles:       roles,
			CreatedAt:   group.CreatedAt,
			UpdatedAt:   group.UpdatedAt,
		}
		if group.CreatedBy != "" {
			result[i].CreatedBy = &group.CreatedBy
		}
		if group.CreatedByEmail != "" {
			result[i].CreatedByEmail = &group.CreatedByEmail
		}
	}

	return result, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id string) (*model.Group, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	if r.PGStore == nil {
		return nil, errors.New("database not configured")
	}

	group, err := r.PGStore.GetGroup(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get group: %w", err)
	}
	if group == nil {
		return nil, fmt.Errorf("group not found")
	}

	// Fetch roles for this group
	roles := []model.Role{}
	for _, roleID := range group.RoleIDs {
		role, err := r.PGStore.GetRole(ctx, roleID)
		if err == nil && role != nil {
			roles = append(roles, model.Role{
				ID:          role.ID,
				Name:        role.Name,
				Description: &role.Description,
				IsDefault:   role.IsDefault,
				IsSystem:    role.IsSystem,
				CreatedAt:   role.CreatedAt,
				UpdatedAt:   role.UpdatedAt,
			})
		}
	}

	return &model.Group{
		ID:          group.ID,
		Name:        group.Name,
		Description: &group.Description,
		Roles:       roles,
		CreatedAt:   group.CreatedAt,
		UpdatedAt:   group.UpdatedAt,
	}, nil
}

// APIKeys is the resolver for the apiKeys field.
func (r *queryResolver) APIKeys(ctx context.Context) ([]model.APIKey, error) {
	// Get tenant context
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, errors.New("tenant context required")
	}

	// Get tenant store
	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("failed to get tenant store: %w", err)
	}

	// List all API keys for this tenant
	apiKeysWithRole, err := tenantStore.ListAPIKeys(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list API keys: %w", err)
	}

	// Convert to GraphQL model
	result := make([]model.APIKey, 0, len(apiKeysWithRole))
	for _, keyWithRole := range apiKeysWithRole {
		gqlKey := model.APIKey{
			ID:         keyWithRole.APIKey.ID,
			Name:       keyWithRole.APIKey.Name,
			KeyPrefix:  keyWithRole.APIKey.KeyPrefix,
			LastUsedAt: keyWithRole.APIKey.LastUsedAt,
			CreatedAt:  keyWithRole.APIKey.CreatedAt,
			ExpiresAt:  keyWithRole.APIKey.ExpiresAt,
			Revoked:    keyWithRole.APIKey.Revoked,
		}

		// Check if expired
		if keyWithRole.APIKey.ExpiresAt != nil && time.Now().After(*keyWithRole.APIKey.ExpiresAt) {
			gqlKey.IsExpired = true
		}

		// Add created by info
		if keyWithRole.APIKey.CreatedBy != "" {
			gqlKey.CreatedBy = &keyWithRole.APIKey.CreatedBy
		}
		if keyWithRole.APIKey.CreatedByEmail != "" {
			gqlKey.CreatedByEmail = &keyWithRole.APIKey.CreatedByEmail
		}

		// Add role if present
		if keyWithRole.RoleID != "" {
			gqlKey.Role = &model.Role{
				ID:   keyWithRole.RoleID,
				Name: keyWithRole.RoleName,
			}
		}

		// Add group if present
		if keyWithRole.GroupID != "" {
			gqlKey.Group = &model.Group{
				ID:   keyWithRole.GroupID,
				Name: keyWithRole.GroupName,
			}
		}

		result = append(result, gqlKey)
	}

	return result, nil
}

// APIKey is the resolver for the apiKey field.
func (r *queryResolver) APIKey(ctx context.Context, id string) (*model.APIKey, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("getting tenant store: %w", err)
	}

	keyWithRole, err := tenantStore.GetAPIKey(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("getting API key: %w", err)
	}
	if keyWithRole == nil {
		return nil, nil
	}

	gqlKey := &model.APIKey{
		ID:         keyWithRole.ID,
		Name:       keyWithRole.Name,
		KeyPrefix:  keyWithRole.KeyPrefix,
		LastUsedAt: keyWithRole.LastUsedAt,
		CreatedAt:  keyWithRole.CreatedAt,
		ExpiresAt:  keyWithRole.ExpiresAt,
		Revoked:    keyWithRole.Revoked,
	}

	if keyWithRole.ExpiresAt != nil && time.Now().After(*keyWithRole.ExpiresAt) {
		gqlKey.IsExpired = true
	}

	if keyWithRole.CreatedBy != "" {
		gqlKey.CreatedBy = &keyWithRole.CreatedBy
	}
	if keyWithRole.CreatedByEmail != "" {
		gqlKey.CreatedByEmail = &keyWithRole.CreatedByEmail
	}

	if keyWithRole.RoleID != "" {
		gqlKey.Role = &model.Role{
			ID:   keyWithRole.RoleID,
			Name: keyWithRole.RoleName,
		}
	}

	if keyWithRole.GroupID != "" {
		gqlKey.Group = &model.Group{
			ID:   keyWithRole.GroupID,
			Name: keyWithRole.GroupName,
		}
	}

	return gqlKey, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]model.User, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("getting tenant store: %w", err)
	}

	users, err := tenantStore.ListUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("listing users: %w", err)
	}

	result := make([]model.User, len(users))
	for i, u := range users {
		result[i] = convertTenantUserToModel(u)
	}

	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("getting tenant store: %w", err)
	}

	user, err := tenantStore.GetUser(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("getting user: %w", err)
	}
	if user == nil {
		return nil, nil
	}

	result := convertTenantUserToModel(user)
	return &result, nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*model.DashboardStats, error) {
	// Get tenant from context
	tenant, ok := ctx.Value("tenant").(*domain.Tenant)
	if !ok || tenant == nil {
		return nil, fmt.Errorf("tenant not found in context")
	}

	// Get tenant slug from metadata
	tenantSlug, ok := tenant.Metadata["slug"]
	if !ok || tenantSlug == "" {
		tenantSlug = tenant.ID
	}

	if r.PGStore == nil {
		// Return empty dashboard if no database
		return &model.DashboardStats{
			TotalRequests:     0,
			TotalTokens:       0,
			TotalCostUsd:      0.0,
			AvgLatencyMs:      0.0,
			ErrorRate:         0.0,
			RequestsByHour:    []model.HourlyStats{},
			CostTrend:         []model.DailyCost{},
			TopModels:         []model.ModelUsage{},
			ProviderBreakdown: []model.ProviderUsage{},
			APIKeyBreakdown:   []model.APIKeyUsage{},
		}, nil
	}

	// Get time ranges
	now := time.Now()
	startOfDay := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
	startOfWeek := now.AddDate(0, 0, -7)
	startOfMonth := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())

	// Get overall stats for the current month
	stats, err := r.PGStore.GetUsageStats(ctx, startOfMonth, now)
	if err != nil {
		log.Printf("Failed to get usage stats: %v", err)
		stats = &domain.UsageStats{}
	}

	// Get hourly stats for today
	hourlyPoints, err := r.PGStore.GetUsageTimeSeries(ctx, startOfDay, now, "hour")
	if err != nil {
		log.Printf("Failed to get hourly stats: %v", err)
		hourlyPoints = []*domain.UsageTimePoint{}
	}

	// Get weekly cost trend
	dailyPoints, err := r.PGStore.GetUsageTimeSeries(ctx, startOfWeek, now, "day")
	if err != nil {
		log.Printf("Failed to get daily stats: %v", err)
		dailyPoints = []*domain.UsageTimePoint{}
	}

	// Get top models
	modelStats, err := r.PGStore.GetUsageStatsByModel(ctx, startOfMonth, now)
	if err != nil {
		log.Printf("Failed to get model stats: %v", err)
		modelStats = make(map[string]*domain.ModelUsageStats)
	}

	// Get provider breakdown
	providerStats, err := r.PGStore.GetUsageStatsByProvider(ctx, startOfMonth, now)
	if err != nil {
		log.Printf("Failed to get provider stats: %v", err)
		providerStats = make(map[string]*domain.ProviderUsageStats)
	}

	// Calculate average latency
	avgLatency := 0.0
	if len(providerStats) > 0 {
		totalLatency := 0.0
		count := 0
		for _, pStats := range providerStats {
			if pStats.AvgLatencyMs > 0 {
				totalLatency += pStats.AvgLatencyMs
				count++
			}
		}
		if count > 0 {
			avgLatency = totalLatency / float64(count)
		}
	}

	// Convert hourly points
	requestsByHour := make([]model.HourlyStats, 0, len(hourlyPoints))
	for _, point := range hourlyPoints {
		requestsByHour = append(requestsByHour, model.HourlyStats{
			Hour:     point.Timestamp.Format("15:04"),
			Requests: int(point.Requests),
			Tokens:   int(point.Tokens),
		})
	}

	// Convert daily points for cost trend
	costTrend := make([]model.DailyCost, 0, len(dailyPoints))
	for _, point := range dailyPoints {
		costTrend = append(costTrend, model.DailyCost{
			Date: point.Timestamp.Format("Mon"),
			Cost: point.CostUSD,
		})
	}

	// Convert top models
	topModels := make([]model.ModelUsage, 0, len(modelStats))
	for modelName, mStats := range modelStats {
		topModels = append(topModels, model.ModelUsage{
			Model:    modelName,
			Requests: int(mStats.Requests),
			Tokens:   int(mStats.InputTokens + mStats.OutputTokens),
			Cost:     mStats.CostUSD,
		})
	}

	// Sort top models by requests (descending)
	for i := 0; i < len(topModels)-1; i++ {
		for j := i + 1; j < len(topModels); j++ {
			if topModels[j].Requests > topModels[i].Requests {
				topModels[i], topModels[j] = topModels[j], topModels[i]
			}
		}
	}

	// Convert provider breakdown
	providerBreakdown := make([]model.ProviderUsage, 0, len(providerStats))
	for providerName, pStats := range providerStats {
		percentage := 0.0
		if stats.TotalRequests > 0 {
			percentage = (float64(pStats.Requests) / float64(stats.TotalRequests)) * 100
		}

		// Map provider name to enum
		var providerEnum model.Provider
		switch providerName {
		case "openai":
			providerEnum = model.ProviderOpenai
		case "anthropic":
			providerEnum = model.ProviderAnthropic
		case "gemini", "google":
			providerEnum = model.ProviderGemini
		case "bedrock":
			providerEnum = model.ProviderBedrock
		case "ollama":
			providerEnum = model.ProviderOllama
		default:
			providerEnum = model.ProviderOpenai
		}

		providerBreakdown = append(providerBreakdown, model.ProviderUsage{
			Provider:   providerEnum,
			Requests:   int(pStats.Requests),
			Percentage: percentage,
		})
	}

	// Get API key breakdown
	apiKeyStats, err := r.PGStore.GetUsageStatsByAPIKey(ctx, startOfMonth, now)
	if err != nil {
		log.Printf("Failed to get API key stats: %v", err)
		apiKeyStats = make(map[string]*domain.APIKeyUsageStats)
	}

	// Convert API key breakdown
	apiKeyBreakdown := make([]model.APIKeyUsage, 0, len(apiKeyStats))
	totalCost := stats.TotalCostUSD
	if totalCost == 0 {
		totalCost = 0.01 // Avoid division by zero
	}

	for _, akStats := range apiKeyStats {
		percentage := (akStats.CostUSD / totalCost) * 100
		apiKeyBreakdown = append(apiKeyBreakdown, model.APIKeyUsage{
			APIKeyID:   akStats.APIKeyID,
			APIKeyName: akStats.APIKeyName,
			Requests:   int(akStats.Requests),
			Tokens:     int(akStats.TotalTokens),
			Cost:       akStats.CostUSD,
			Percentage: percentage,
		})
	}

	// Sort API key breakdown by cost (descending)
	for i := 0; i < len(apiKeyBreakdown)-1; i++ {
		for j := i + 1; j < len(apiKeyBreakdown); j++ {
			if apiKeyBreakdown[j].Cost > apiKeyBreakdown[i].Cost {
				apiKeyBreakdown[i], apiKeyBreakdown[j] = apiKeyBreakdown[j], apiKeyBreakdown[i]
			}
		}
	}

	return &model.DashboardStats{
		TotalRequests:     int(stats.TotalRequests),
		TotalTokens:       int(stats.TotalTokens),
		TotalCostUsd:      stats.TotalCostUSD,
		AvgLatencyMs:      avgLatency,
		ErrorRate:         0.0, // TODO: Calculate from success/error records
		RequestsByHour:    requestsByHour,
		CostTrend:         costTrend,
		TopModels:         topModels,
		ProviderBreakdown: providerBreakdown,
		APIKeyBreakdown:   apiKeyBreakdown,
	}, nil
}

// RequestLogs is the resolver for the requestLogs field.
func (r *queryResolver) RequestLogs(ctx context.Context, filter *model.RequestLogFilter, first *int, after *string) (*model.RequestLogConnection, error) {
	// Set default limit
	limit := 50
	if first != nil && *first > 0 {
		limit = *first
	}

	// Parse filter parameters
	var modelFilter, statusFilter, apiKeyIDFilter string
	startTime := time.Now().AddDate(0, 0, -30) // Default to last 30 days
	endTime := time.Now()

	if filter != nil {
		if filter.Model != nil {
			modelFilter = *filter.Model
		}
		if filter.Status != nil {
			statusFilter = *filter.Status
		}
		if filter.APIKeyID != nil {
			apiKeyIDFilter = *filter.APIKeyID
		}
		if filter.StartDate != nil {
			startTime = *filter.StartDate
		}
		if filter.EndDate != nil {
			endTime = *filter.EndDate
		}
	}

	// Query database
	records, err := r.PGStore.ListUsageRecords(ctx, startTime, endTime, modelFilter, statusFilter, apiKeyIDFilter, limit)
	if err != nil {
		log.Printf("Failed to list usage records: %v", err)
		return &model.RequestLogConnection{
			Edges:      []model.RequestLog{},
			PageInfo:   &model.PageInfo{HasNextPage: false, HasPreviousPage: false},
			TotalCount: 0,
		}, nil
	}

	// Convert to GraphQL model
	edges := make([]model.RequestLog, 0, len(records))
	for _, record := range records {
		// Map provider string to enum
		var providerEnum model.Provider
		switch strings.ToLower(string(record.Provider)) {
		case "gemini":
			providerEnum = model.ProviderGemini
		case "anthropic":
			providerEnum = model.ProviderAnthropic
		case "openai":
			providerEnum = model.ProviderOpenai
		case "bedrock":
			providerEnum = model.ProviderBedrock
		case "ollama":
			providerEnum = model.ProviderOllama
		default:
			providerEnum = model.ProviderOpenai
		}

		// Convert Success bool to status string
		status := "success"
		if !record.Success {
			status = "error"
		}

		// Convert optional fields to pointers
		var apiKeyName, errorCode, errorMessage *string
		if record.APIKeyName != "" {
			apiKeyName = &record.APIKeyName
		}
		if record.ErrorCode != "" {
			errorCode = &record.ErrorCode
		}
		if record.ErrorMessage != "" {
			errorMessage = &record.ErrorMessage
		}

		edges = append(edges, model.RequestLog{
			ID:           record.ID,
			Model:        record.Model,
			Provider:     providerEnum,
			Status:       status,
			InputTokens:  int(record.InputTokens),
			OutputTokens: int(record.OutputTokens),
			LatencyMs:    int(record.LatencyMs),
			CostUsd:      record.CostUSD,
			APIKeyName:   apiKeyName,
			ErrorCode:    errorCode,
			ErrorMessage: errorMessage,
			CreatedAt:    record.Timestamp,
		})
	}

	return &model.RequestLogConnection{
		Edges:      edges,
		PageInfo:   &model.PageInfo{HasNextPage: len(records) >= limit, HasPreviousPage: false},
		TotalCount: len(edges),
	}, nil
}

// RequestLog is the resolver for the requestLog field.
func (r *queryResolver) RequestLog(ctx context.Context, id string) (*model.RequestLogDetail, error) {
	// Query database
	record, err := r.PGStore.GetUsageRecord(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("request log not found: %w", err)
	}

	// Map provider string to enum
	var providerEnum model.Provider
	switch strings.ToLower(string(record.Provider)) {
	case "gemini":
		providerEnum = model.ProviderGemini
	case "anthropic":
		providerEnum = model.ProviderAnthropic
	case "openai":
		providerEnum = model.ProviderOpenai
	case "bedrock":
		providerEnum = model.ProviderBedrock
	case "ollama":
		providerEnum = model.ProviderOllama
	default:
		providerEnum = model.ProviderOpenai
	}

	// Convert Success bool to status string
	status := "success"
	if !record.Success {
		status = "error"
	}

	// Extract prompt and response from metadata
	var prompt, response *string
	if record.Metadata != nil {
		if p, ok := record.Metadata["prompt"].(string); ok && p != "" {
			prompt = &p
		}
		if r, ok := record.Metadata["response"].(string); ok && r != "" {
			response = &r
		}
	}

	// Convert error fields to pointers
	var errorCode, errorMessage, apiKeyName *string
	if record.ErrorCode != "" {
		errorCode = &record.ErrorCode
	}
	if record.ErrorMessage != "" {
		errorMessage = &record.ErrorMessage
	}
	if record.APIKeyName != "" {
		apiKeyName = &record.APIKeyName
	}

	return &model.RequestLogDetail{
		ID:           record.ID,
		Model:        record.Model,
		Provider:     providerEnum,
		Status:       status,
		InputTokens:  int(record.InputTokens),
		OutputTokens: int(record.OutputTokens),
		LatencyMs:    int(record.LatencyMs),
		CostUsd:      record.CostUSD,
		APIKeyName:   apiKeyName,
		ErrorCode:    errorCode,
		ErrorMessage: errorMessage,
		CreatedAt:    record.Timestamp,
		Prompt:       prompt,
		Response:     response,
		Metadata:     record.Metadata,
	}, nil
}

// CostAnalysis is the resolver for the costAnalysis field.
func (r *queryResolver) CostAnalysis(ctx context.Context, startDate *time.Time, endDate *time.Time) (*model.CostAnalysis, error) {
	// Set default date range to last month
	start := time.Now().AddDate(0, -1, 0)
	end := time.Now()
	if startDate != nil {
		start = *startDate
	}
	if endDate != nil {
		end = *endDate
	}

	// Get overall stats
	stats, err := r.PGStore.GetUsageStats(ctx, start, end)
	if err != nil {
		log.Printf("Failed to get usage stats: %v", err)
		stats = &domain.UsageStats{}
	}

	// Get daily time series
	timeSeries, err := r.PGStore.GetUsageTimeSeries(ctx, start, end, "day")
	if err != nil {
		log.Printf("Failed to get time series: %v", err)
		timeSeries = []*domain.UsageTimePoint{}
	}

	// Convert to daily costs
	dailyCosts := make([]model.DailyCost, 0, len(timeSeries))
	for _, point := range timeSeries {
		dailyCosts = append(dailyCosts, model.DailyCost{
			Date: point.Timestamp.Format("2006-01-02"),
			Cost: point.CostUSD,
		})
	}

	// Get provider breakdown
	providerStats, err := r.PGStore.GetUsageStatsByProvider(ctx, start, end)
	if err != nil {
		log.Printf("Failed to get provider stats: %v", err)
		providerStats = make(map[string]*domain.ProviderUsageStats)
	}

	costByProvider := make([]model.ProviderCost, 0, len(providerStats))
	totalCost := stats.TotalCostUSD
	if totalCost == 0 {
		totalCost = 0.01 // Avoid division by zero
	}
	for provider, pStats := range providerStats {
		var providerEnum model.Provider
		switch strings.ToLower(provider) {
		case "gemini":
			providerEnum = model.ProviderGemini
		case "anthropic":
			providerEnum = model.ProviderAnthropic
		case "openai":
			providerEnum = model.ProviderOpenai
		case "bedrock":
			providerEnum = model.ProviderBedrock
		case "ollama":
			providerEnum = model.ProviderOllama
		default:
			providerEnum = model.ProviderOpenai
		}

		percentage := (pStats.CostUSD / totalCost) * 100
		costByProvider = append(costByProvider, model.ProviderCost{
			Provider:   providerEnum,
			Cost:       pStats.CostUSD,
			Percentage: percentage,
		})
	}

	// Get model breakdown
	modelStats, err := r.PGStore.GetUsageStatsByModel(ctx, start, end)
	if err != nil {
		log.Printf("Failed to get model stats: %v", err)
		modelStats = make(map[string]*domain.ModelUsageStats)
	}

	costByModel := make([]model.ModelCost, 0, len(modelStats))
	for modelID, mStats := range modelStats {
		costByModel = append(costByModel, model.ModelCost{
			Model:    modelID,
			Cost:     mStats.CostUSD,
			Requests: int(mStats.Requests),
		})
	}

	// Calculate projected monthly cost (extrapolate from current period)
	daysSoFar := end.Sub(start).Hours() / 24
	projectedMonthlyCost := 0.0
	if daysSoFar > 0 {
		projectedMonthlyCost = (stats.TotalCostUSD / daysSoFar) * 30
	}

	// Budget utilization (no quotas in single-tenant mode)
	budgetUtilization := 0.0

	return &model.CostAnalysis{
		TotalCost:            stats.TotalCostUSD,
		PeriodStart:          start,
		PeriodEnd:            end,
		DailyCosts:           dailyCosts,
		CostByProvider:       costByProvider,
		CostByModel:          costByModel,
		ProjectedMonthlyCost: projectedMonthlyCost,
		BudgetUtilization:    budgetUtilization,
	}, nil
}

// Performance is the resolver for the performance field.
func (r *queryResolver) Performance(ctx context.Context, startDate *time.Time, endDate *time.Time) (*model.PerformanceMetrics, error) {
	// Set default date range to last 7 days
	start := time.Now().AddDate(0, 0, -7)
	end := time.Now()
	if startDate != nil {
		start = *startDate
	}
	if endDate != nil {
		end = *endDate
	}

	// Get provider stats for average latency
	providerStats, err := r.PGStore.GetUsageStatsByProvider(ctx, start, end)
	if err != nil {
		log.Printf("Failed to get provider stats: %v", err)
		providerStats = make(map[string]*domain.ProviderUsageStats)
	}

	// Calculate average latency across all providers
	avgLatency := 0.0
	if len(providerStats) > 0 {
		totalLatency := 0.0
		count := 0
		for _, pStats := range providerStats {
			if pStats.AvgLatencyMs > 0 {
				totalLatency += pStats.AvgLatencyMs
				count++
			}
		}
		if count > 0 {
			avgLatency = totalLatency / float64(count)
		}
	}

	// Get model stats for per-model performance
	modelStats, err := r.PGStore.GetUsageStatsByModel(ctx, start, end)
	if err != nil {
		log.Printf("Failed to get model stats: %v", err)
		modelStats = make(map[string]*domain.ModelUsageStats)
	}

	modelPerformance := make([]model.ModelPerformance, 0, len(modelStats))
	for modelID, mStats := range modelStats {
		// Calculate success rate (TODO: need success/failure tracking in DB)
		successRate := 99.0 // Default placeholder

		// Use average latency from overall stats as estimate
		// TODO: Track latency per model in database
		modelAvgLatency := avgLatency

		modelPerformance = append(modelPerformance, model.ModelPerformance{
			Model:        modelID,
			AvgLatencyMs: modelAvgLatency,
			SuccessRate:  successRate,
			RequestCount: int(mStats.Requests),
		})
	}

	// Calculate success and error rates
	// TODO: Need to track success/failure in usage_records table
	successRate := 99.0 // Placeholder
	errorRate := 1.0    // Placeholder

	return &model.PerformanceMetrics{
		AvgLatencyMs:     avgLatency,
		P50LatencyMs:     avgLatency * 0.8, // Estimated (TODO: calculate from actual percentiles)
		P95LatencyMs:     avgLatency * 1.8, // Estimated
		P99LatencyMs:     avgLatency * 2.5, // Estimated
		SuccessRate:      successRate,
		ErrorRate:        errorRate,
		ModelPerformance: modelPerformance,
	}, nil
}

// AgentDashboard is the resolver for the agentDashboard field.
func (r *queryResolver) AgentDashboard(ctx context.Context, apiKeyID string, startTime time.Time, endTime time.Time) (*model.AgentDashboardStats, error) {
	// Single-tenant mode - use default tenant store
	if r.PGStore == nil {
		return nil, fmt.Errorf("database not available")
	}

	tenantStore := r.PGStore.TenantStore()
	dashboardStore := tenantStore.AgentDashboardStore()
	if dashboardStore == nil {
		return nil, fmt.Errorf("agent dashboard store not available")
	}

	// Fetch all dashboard data (using "default" as tenant ID for single-tenant mode)
	stats, err := dashboardStore.GetStats(ctx, "default", apiKeyID, startTime, endTime)
	if err != nil {
		return nil, fmt.Errorf("failed to get agent dashboard stats: %w", err)
	}

	// Convert domain types to GraphQL model types
	return convertAgentDashboardStats(stats), nil
}

// convertAgentDashboardStats converts domain.AgentDashboardStats to model.AgentDashboardStats
func convertAgentDashboardStats(stats *domain.AgentDashboardStats) *model.AgentDashboardStats {
	if stats == nil {
		return nil
	}

	// Convert provider/model usage
	providerModelUsage := make([]model.ProviderModelUsage, len(stats.ProviderUsage))
	for i, usage := range stats.ProviderUsage {
		providerModelUsage[i] = model.ProviderModelUsage{
			Provider:     usage.Provider,
			Model:        usage.Model,
			RequestCount: int(usage.RequestCount),
			TokenCount:   int(usage.TokenCount),
			CostUsd:      usage.CostUSD,
		}
	}

	// Convert token metrics
	tokenMetrics := convertTokenMetrics(&stats.TokenMetrics)

	// Convert cache metrics
	cacheMetrics := convertCacheMetrics(&stats.CacheStats)

	// Convert tool call metrics
	toolCallMetrics := convertToolCallMetrics(stats.ToolCallStats)

	// Convert risk assessment
	riskAssessment := convertRiskAssessment(&stats.RiskScore, stats.Violations)

	return &model.AgentDashboardStats{
		ProviderModelUsage: providerModelUsage,
		TokenMetrics:       tokenMetrics,
		CacheMetrics:       cacheMetrics,
		ToolCallMetrics:    toolCallMetrics,
		RiskAssessment:     riskAssessment,
	}
}

// convertTokenMetrics converts domain.TokenMetrics to model.TokenMetrics
func convertTokenMetrics(metrics *domain.TokenMetrics) *model.TokenMetrics {
	if metrics == nil {
		return nil
	}

	// Convert ByModel map to slice
	byModel := make([]model.ModelTokenBreakdown, 0, len(metrics.ByModel))
	for modelName, breakdown := range metrics.ByModel {
		byModel = append(byModel, model.ModelTokenBreakdown{
			Model:          modelName,
			InputTokens:    int(breakdown.InputTokens),
			OutputTokens:   int(breakdown.OutputTokens),
			ThinkingTokens: int(breakdown.ThinkingTokens),
			CostUsd:        breakdown.CostUSD,
		})
	}

	return &model.TokenMetrics{
		TotalInput:    int(metrics.TotalInput),
		TotalOutput:   int(metrics.TotalOutput),
		TotalThinking: int(metrics.TotalThinking),
		TotalCost:     metrics.TotalCost,
		ByModel:       byModel,
	}
}

// convertCacheMetrics converts domain.CacheStatistics to model.AgentCacheMetrics
func convertCacheMetrics(cache *domain.CacheStatistics) *model.AgentCacheMetrics {
	if cache == nil {
		return nil
	}

	return &model.AgentCacheMetrics{
		TotalHits:   int(cache.TotalHits),
		TotalMisses: int(cache.TotalMisses),
		HitRate:     cache.HitRate,
		TokensSaved: int(cache.TokensSaved),
		CostSaved:   cache.CostSavedUSD,
	}
}

// convertToolCallMetrics converts []domain.ToolCallStatistic to model.ToolCallMetrics
func convertToolCallMetrics(toolCalls []domain.ToolCallStatistic) *model.ToolCallMetrics {
	if len(toolCalls) == 0 {
		return &model.ToolCallMetrics{
			TotalCalls:   0,
			SuccessCount: 0,
			FailureCount: 0,
			SuccessRate:  0,
			ByTool:       []model.ToolCallBreakdown{},
		}
	}

	// Calculate totals
	var totalCalls, successCount, failureCount int
	byTool := make([]model.ToolCallBreakdown, len(toolCalls))

	for i, stat := range toolCalls {
		totalCalls += int(stat.TotalCount)
		successCount += int(stat.SuccessCount)
		failureCount += int(stat.FailureCount)

		byTool[i] = model.ToolCallBreakdown{
			ToolName:     stat.ToolName,
			SuccessCount: int(stat.SuccessCount),
			FailureCount: int(stat.FailureCount),
			TotalCount:   int(stat.TotalCount),
		}
	}

	// Calculate success rate
	var successRate float64
	if totalCalls > 0 {
		successRate = (float64(successCount) / float64(totalCalls)) * 100
	}

	return &model.ToolCallMetrics{
		TotalCalls:   totalCalls,
		SuccessCount: successCount,
		FailureCount: failureCount,
		SuccessRate:  successRate,
		ByTool:       byTool,
	}
}

// convertRiskAssessment converts domain.RiskAssessment and violations to model.RiskAssessment
func convertRiskAssessment(risk *domain.RiskAssessment, violations []domain.PolicyViolationStat) *model.RiskAssessment {
	if risk == nil {
		return nil
	}

	// Convert policy violation stats to summaries
	policyViolations := make([]model.PolicyViolationSummary, len(violations))
	for i, v := range violations {
		policyViolations[i] = model.PolicyViolationSummary{
			ViolationType: v.ViolationType,
			Count:         int(v.Count),
			AvgSeverity:   v.AvgSeverity,
		}
	}

	// Generate recommendations based on risk level and violations
	recommendations := generateRecommendations(risk, violations)

	return &model.RiskAssessment{
		OverallRiskScore: risk.Score,
		RiskLevel:        risk.Level,
		PolicyViolations: policyViolations,
		RecentViolations: []model.PolicyViolationRecord{}, // Empty for now - can be populated later if needed
		Recommendations:  recommendations,
	}
}

// generateRecommendations generates security recommendations based on risk assessment
func generateRecommendations(risk *domain.RiskAssessment, violations []domain.PolicyViolationStat) []string {
	recommendations := []string{}

	// Add recommendations based on risk level
	if risk.Level == "high" || risk.Level == "critical" {
		recommendations = append(recommendations, "Immediate review required: High risk detected")
	}

	// Add recommendations based on specific violations
	violationTypes := make(map[string]bool)
	for _, v := range violations {
		violationTypes[v.ViolationType] = true
	}

	if violationTypes["prompt_injection"] {
		recommendations = append(recommendations, "Consider implementing stricter prompt validation")
	}
	if violationTypes["unauthorized_tool_access"] {
		recommendations = append(recommendations, "Review and tighten tool access policies")
	}
	if violationTypes["rate_limit_exceeded"] {
		recommendations = append(recommendations, "Increase rate limits or investigate unusual activity")
	}
	if violationTypes["cost_limit_exceeded"] {
		recommendations = append(recommendations, "Review budget allocation or optimize model usage")
	}
	if violationTypes["content_filter"] {
		recommendations = append(recommendations, "Review content filtering policies and training data")
	}

	// If no specific recommendations, add general one
	if len(recommendations) == 0 && risk.Violations > 0 {
		recommendations = append(recommendations, "Monitor policy violations and adjust settings as needed")
	}

	return recommendations
}

// BudgetAlerts is the resolver for the budgetAlerts field.
func (r *queryResolver) BudgetAlerts(ctx context.Context) ([]model.BudgetAlert, error) {
	return []model.BudgetAlert{}, nil
}

// BudgetAlert is the resolver for the budgetAlert field.
func (r *queryResolver) BudgetAlert(ctx context.Context, id string) (*model.BudgetAlert, error) {
	return nil, fmt.Errorf("not found")
}

// AuditLogs is the resolver for the auditLogs field.
func (r *queryResolver) AuditLogs(ctx context.Context, filter *model.AuditLogFilter, limit *int, offset *int) (*model.AuditLogConnection, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("getting tenant store: %w", err)
	}

	domainFilter := domain.AuditLogFilter{
		Limit:  100, // default
		Offset: 0,
	}

	if filter != nil {
		if filter.ResourceType != nil {
			domainFilter.ResourceType = domain.AuditResourceType(strings.ToLower(string(*filter.ResourceType)))
		}
		if filter.ResourceID != nil {
			domainFilter.ResourceID = *filter.ResourceID
		}
		if filter.Action != nil {
			domainFilter.Action = domain.AuditAction(strings.ToLower(string(*filter.Action)))
		}
		if filter.ActorID != nil {
			domainFilter.ActorID = *filter.ActorID
		}
		if filter.StartTime != nil {
			domainFilter.StartTime = *filter.StartTime
		}
		if filter.EndTime != nil {
			domainFilter.EndTime = *filter.EndTime
		}
	}

	if limit != nil && *limit > 0 {
		domainFilter.Limit = *limit
	}
	if offset != nil && *offset > 0 {
		domainFilter.Offset = *offset
	}

	logs, err := tenantStore.ListAuditLogs(ctx, domainFilter)
	if err != nil {
		return nil, fmt.Errorf("listing audit logs: %w", err)
	}

	count, err := tenantStore.CountAuditLogs(ctx, domainFilter)
	if err != nil {
		return nil, fmt.Errorf("counting audit logs: %w", err)
	}

	items := make([]model.AuditLog, len(logs))
	for i, log := range logs {
		items[i] = convertDomainAuditLogToModel(log)
	}

	return &model.AuditLogConnection{
		Items:      items,
		TotalCount: count,
		HasMore:    domainFilter.Offset+len(logs) < count,
	}, nil
}

// AuditLog is the resolver for the auditLog field.
func (r *queryResolver) AuditLog(ctx context.Context, id string) (*model.AuditLog, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not specified")
	}

	tenantStore, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, fmt.Errorf("getting tenant store: %w", err)
	}

	log, err := tenantStore.GetAuditLog(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("getting audit log: %w", err)
	}
	if log == nil {
		return nil, nil
	}

	result := convertDomainAuditLogToModel(*log)
	return &result, nil
}

// DiscoveredTools is the resolver for the discoveredTools field.
func (r *queryResolver) DiscoveredTools(ctx context.Context, filter *model.DiscoveredToolFilter, limit *int, offset *int) (*model.DiscoveredToolConnection, error) {
	return r.DiscoveredToolsImpl(ctx, filter, limit, offset)
}

// DiscoveredTool is the resolver for the discoveredTool field.
func (r *queryResolver) DiscoveredTool(ctx context.Context, id string) (*model.DiscoveredTool, error) {
	return r.DiscoveredToolImpl(ctx, id)
}

// RoleToolPermissions is the resolver for the roleToolPermissions field.
func (r *queryResolver) RoleToolPermissions(ctx context.Context, roleID string) ([]model.ToolWithPermission, error) {
	return r.RoleToolPermissionsImpl(ctx, roleID)
}

// PendingTools is the resolver for the pendingTools field.
func (r *queryResolver) PendingTools(ctx context.Context) ([]model.DiscoveredTool, error) {
	return r.PendingToolsImpl(ctx)
}

// ToolExecutionLogs is the resolver for the toolExecutionLogs field.
func (r *queryResolver) ToolExecutionLogs(ctx context.Context, filter *model.ToolExecutionLogFilter, limit *int, offset *int) (*model.ToolExecutionLogConnection, error) {
	return r.ToolExecutionLogsImpl(ctx, filter, limit, offset)
}

// McpServers returns all MCP servers for the tenant
func (r *queryResolver) McpServers(ctx context.Context) ([]model.MCPServer, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	servers, err := store.ListMCPServers(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]model.MCPServer, len(servers))
	for i, s := range servers {
		result[i] = *domainToMCPServerModel(s)
	}

	return result, nil
}

// McpServer returns an MCP server by ID
func (r *queryResolver) McpServer(ctx context.Context, id string) (*model.MCPServer, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	server, err := store.GetMCPServer(ctx, id)
	if err != nil {
		return nil, err
	}
	if server == nil {
		return nil, nil
	}

	return domainToMCPServerModel(server), nil
}

// McpTools returns MCP tools, optionally filtered by server
func (r *queryResolver) McpTools(ctx context.Context, serverID *string, category *string) ([]model.MCPTool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	var tools []*domain.MCPTool
	if serverID != nil {
		tools, err = store.ListMCPTools(ctx, *serverID)
	} else {
		// Use ListAllMCPTools since the store is already tenant-scoped
		tools, err = store.ListAllMCPTools(ctx)
	}
	if err != nil {
		return nil, err
	}

	// Filter by category if specified
	if category != nil {
		filtered := make([]*domain.MCPTool, 0)
		for _, t := range tools {
			if t.Category == *category {
				filtered = append(filtered, t)
			}
		}
		tools = filtered
	}

	result := make([]model.MCPTool, len(tools))
	for i, t := range tools {
		result[i] = *domainToMCPToolModel(t)
	}

	return result, nil
}

// McpTool returns an MCP tool by ID
func (r *queryResolver) McpTool(ctx context.Context, id string) (*model.MCPTool, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	tool, err := store.GetMCPTool(ctx, id)
	if err != nil {
		return nil, err
	}
	if tool == nil {
		return nil, nil
	}

	return domainToMCPToolModel(tool), nil
}

// SearchTools searches for tools using the MCP gateway
func (r *queryResolver) SearchTools(ctx context.Context, input model.ToolSearchInput) (*model.ToolSearchResponse, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	if r.mcpGateway == nil {
		return nil, fmt.Errorf("MCP gateway not configured")
	}

	// Build search request
	req := &domain.ToolSearchRequest{
		Query:         input.Query,
		Strategy:      domain.SearchStrategyHybrid,
		MaxResults:    10,
		IncludeSchema: false,
	}

	if input.Strategy != nil {
		req.Strategy = domain.SearchStrategy(*input.Strategy)
	}
	if input.MaxResults != nil {
		req.MaxResults = *input.MaxResults
	}
	if input.MinScore != nil {
		req.MinScore = *input.MinScore
	}
	if input.IncludeSchema != nil {
		req.IncludeSchema = *input.IncludeSchema
	}
	if len(input.ServerIds) > 0 {
		req.ServerIDs = input.ServerIds
	}
	if len(input.Categories) > 0 {
		req.Categories = input.Categories
	}

	// RoleID is optional - if not provided, no visibility filtering is applied (admin view)
	roleID := ""
	if input.RoleID != nil {
		roleID = *input.RoleID
	}

	response, err := r.mcpGateway.SearchTools(ctx, tenantSlug, roleID, req)
	if err != nil {
		return nil, err
	}

	return domainToToolSearchResponse(response), nil
}

// McpServerVersions returns version history for a server
func (r *queryResolver) McpServerVersions(ctx context.Context, serverID string) ([]model.MCPServerVersion, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	versions, err := store.ListMCPServerVersions(ctx, serverID)
	if err != nil {
		return nil, err
	}

	result := make([]model.MCPServerVersion, len(versions))
	for i, v := range versions {
		result[i] = *domainToMCPServerVersionModel(v)
	}

	return result, nil
}

// McpPermissions returns MCP permissions for a role
func (r *queryResolver) McpPermissions(ctx context.Context, roleID string) ([]model.MCPToolPermission, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	perms, err := store.ListMCPPermissions(ctx, roleID)
	if err != nil {
		return nil, err
	}

	result := make([]model.MCPToolPermission, len(perms))
	for i, p := range perms {
		result[i] = *domainToMCPToolPermissionModel(p)
	}

	return result, nil
}

// McpToolExecutions returns MCP tool execution logs
func (r *queryResolver) McpToolExecutions(ctx context.Context, limit *int, offset *int) ([]model.MCPToolExecution, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	l := 50
	o := 0
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	execs, _, err := store.ListMCPToolExecutions(ctx, l, o)
	if err != nil {
		return nil, err
	}

	result := make([]model.MCPToolExecution, len(execs))
	for i, e := range execs {
		result[i] = domainToMCPToolExecutionModel(e)
	}

	return result, nil
}

// MCPServersWithTools returns all MCP servers with their tools and visibility for a role
func (r *queryResolver) McpServersWithTools(ctx context.Context, roleID string) ([]model.MCPServerWithTools, error) {
	tenantSlug := GetTenantFromContext(ctx)
	if tenantSlug == "" {
		return nil, fmt.Errorf("tenant not found in context")
	}

	store, err := r.PGStore.GetTenantStore(tenantSlug)
	if err != nil {
		return nil, err
	}

	// Get all servers
	servers, err := store.ListMCPServers(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]model.MCPServerWithTools, len(servers))
	for i, server := range servers {
		// Get tools with visibility for this server
		toolsWithVis, err := store.GetMCPToolsWithVisibility(ctx, server.ID, roleID)
		if err != nil {
			return nil, err
		}

		// Convert to model
		tools := make([]model.MCPToolWithVisibility, len(toolsWithVis))
		allowedCount, searchCount, deniedCount := 0, 0, 0

		for j, tv := range toolsWithVis {
			tools[j] = model.MCPToolWithVisibility{
				Tool:       domainToMCPToolModel(tv.Tool),
				Visibility: model.MCPToolVisibility(tv.Visibility),
			}
			if tv.DecidedBy != "" {
				tools[j].DecidedBy = &tv.DecidedBy
			}
			if tv.DecidedAt != nil {
				tools[j].DecidedAt = tv.DecidedAt
			}

			// Count visibility states
			switch tv.Visibility {
			case domain.MCPVisibilityAllow:
				allowedCount++
			case domain.MCPVisibilitySearch:
				searchCount++
			case domain.MCPVisibilityDeny:
				deniedCount++
			}
		}

		result[i] = model.MCPServerWithTools{
			Server: domainToMCPServerModel(server),
			Tools:  tools,
			Stats: &model.MCPServerToolStats{
				TotalTools:   len(tools),
				AllowedCount: allowedCount,
				SearchCount:  searchCount,
				DeniedCount:  deniedCount,
			},
		}
	}

	return result, nil
}

// AdvancedMetrics is the resolver for the advancedMetrics field.
func (r *queryResolver) AdvancedMetrics(ctx context.Context) (*model.AdvancedMetrics, error) {
	cache, err := r.CacheMetrics(ctx)
	if err != nil {
		return nil, err
	}
	routing, err := r.RoutingMetrics(ctx)
	if err != nil {
		return nil, err
	}
	resilience, err := r.ResilienceMetrics(ctx)
	if err != nil {
		return nil, err
	}
	health, err := r.ProviderHealthMetrics(ctx)
	if err != nil {
		return nil, err
	}

	return &model.AdvancedMetrics{
		Cache:          cache,
		Routing:        routing,
		Resilience:     resilience,
		ProviderHealth: health,
	}, nil
}

// CacheMetrics is the resolver for the cacheMetrics field.
func (r *queryResolver) CacheMetrics(ctx context.Context) (*model.CacheMetrics, error) {
	// Single-tenant mode - use default tenant store
	store := r.PGStore.TenantStore()

	metrics, err := store.GetCacheMetrics(ctx)
	if err != nil {
		// Return empty metrics if query fails (tables might not exist)
		return &model.CacheMetrics{
			Hits:         0,
			Misses:       0,
			HitRate:      0,
			TokensSaved:  0,
			CostSaved:    0,
			AvgLatencyMs: 0,
			Entries:      0,
		}, nil
	}

	return &model.CacheMetrics{
		Hits:         metrics.Hits,
		Misses:       metrics.Misses,
		HitRate:      metrics.HitRate,
		TokensSaved:  int(metrics.TokensSaved),
		CostSaved:    metrics.CostSaved,
		AvgLatencyMs: metrics.AvgLatency,
		Entries:      metrics.Entries,
	}, nil
}

// RoutingMetrics is the resolver for the routingMetrics field.
func (r *queryResolver) RoutingMetrics(ctx context.Context) (*model.RoutingMetrics, error) {
	// Single-tenant mode - use default tenant store
	store := r.PGStore.TenantStore()

	metrics, err := store.GetRoutingMetrics(ctx)
	if err != nil {
		// Return empty metrics if query fails
		return &model.RoutingMetrics{
			Decisions:            0,
			StrategyDistribution: []model.StrategyCount{},
			ModelSwitches:        []model.ModelSwitch{},
			Failures:             0,
		}, nil
	}

	// Convert strategy distribution
	strategyDist := make([]model.StrategyCount, len(metrics.StrategyDistribution))
	for i, sc := range metrics.StrategyDistribution {
		strategyDist[i] = model.StrategyCount{
			Strategy: sc.Strategy,
			Count:    sc.Count,
		}
	}

	// Convert model switches
	modelSwitches := make([]model.ModelSwitch, len(metrics.ModelSwitches))
	for i, ms := range metrics.ModelSwitches {
		modelSwitches[i] = model.ModelSwitch{
			FromModel: ms.FromModel,
			ToModel:   ms.ToModel,
			Count:     ms.Count,
		}
	}

	return &model.RoutingMetrics{
		Decisions:            metrics.Decisions,
		StrategyDistribution: strategyDist,
		ModelSwitches:        modelSwitches,
		Failures:             metrics.Failures,
	}, nil
}

// ResilienceMetrics is the resolver for the resilienceMetrics field.
func (r *queryResolver) ResilienceMetrics(ctx context.Context) (*model.ResilienceMetrics, error) {
	// Single-tenant mode - use default tenant store
	store := r.PGStore.TenantStore()

	metrics, err := store.GetResilienceMetrics(ctx)
	if err != nil {
		// Return empty metrics if query fails
		return &model.ResilienceMetrics{
			CircuitBreakers:     []model.CircuitBreakerInfo{},
			RetryAttempts:       0,
			FallbackInvocations: 0,
			FallbackSuccessRate: 0,
		}, nil
	}

	// Convert circuit breakers
	circuitBreakers := make([]model.CircuitBreakerInfo, len(metrics.CircuitBreakers))
	for i, cb := range metrics.CircuitBreakers {
		circuitBreakers[i] = model.CircuitBreakerInfo{
			Provider: cb.Provider,
			State:    cb.State,
			Failures: cb.Failures,
		}
	}

	return &model.ResilienceMetrics{
		CircuitBreakers:     circuitBreakers,
		RetryAttempts:       metrics.RetryAttempts,
		FallbackInvocations: metrics.FallbackInvocations,
		FallbackSuccessRate: metrics.FallbackSuccessRate,
	}, nil
}

// ProviderHealthMetrics is the resolver for the providerHealthMetrics field.
func (r *queryResolver) ProviderHealthMetrics(ctx context.Context) (*model.ProviderHealthMetrics, error) {
	// Single-tenant mode - use default tenant store
	store := r.PGStore.TenantStore()

	metrics, err := store.GetProviderHealthMetrics(ctx)
	if err != nil {
		// Return empty metrics if query fails
		return &model.ProviderHealthMetrics{
			Providers: []model.ProviderHealthInfo{},
		}, nil
	}

	// Convert provider health info
	providers := make([]model.ProviderHealthInfo, len(metrics))
	for i, p := range metrics {
		providers[i] = model.ProviderHealthInfo{
			Provider:     p.Provider,
			Model:        p.Model,
			HealthScore:  p.HealthScore,
			SuccessRate:  p.SuccessRate,
			P95LatencyMs: p.P95LatencyMs,
			Requests:     p.Requests,
		}
	}

	return &model.ProviderHealthMetrics{
		Providers: providers,
	}, nil
}

// RequestLogAdded is the resolver for the requestLogAdded field.
func (r *subscriptionResolver) RequestLogAdded(ctx context.Context) (<-chan *model.RequestLog, error) {
	ch := make(chan *model.RequestLog)
	go func() { <-ctx.Done(); close(ch) }()
	return ch, nil
}

// DashboardUpdated is the resolver for the dashboardUpdated field.
func (r *subscriptionResolver) DashboardUpdated(ctx context.Context) (<-chan *model.DashboardStats, error) {
	ch := make(chan *model.DashboardStats)
	go func() { <-ctx.Done(); close(ch) }()
	return ch, nil
}

// BudgetAlertTriggered is the resolver for the budgetAlertTriggered field.
func (r *subscriptionResolver) BudgetAlertTriggered(ctx context.Context, alertID *string) (<-chan *model.BudgetAlert, error) {
	ch := make(chan *model.BudgetAlert)
	go func() { <-ctx.Done(); close(ch) }()
	return ch, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// ProviderConfig returns generated.ProviderConfigResolver implementation.
func (r *Resolver) ProviderConfig() generated.ProviderConfigResolver {
	return &providerConfigResolver{r}
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type providerConfigResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
